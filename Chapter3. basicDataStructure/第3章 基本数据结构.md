# 第3章 基本数据结构

## 3.1 本章目标

- 理解栈、队列、双端队列、列表等抽象数据类型
- 能够使用Python列表实现栈、队列和双端队列
- 理解基础线性数据结构的性能
- 理解前序、中序和后序表达式
- 使用栈来计算后序表达式
- 使用栈将中序表达式转换成后序表达式
- 使用队列进行基本的时序模拟
- 理解栈、队列以及双端队列适用于解决何种问题
- 能够使用"节点与引用"模式将列表实现为列表
- 能够从性能方面比较自己的链表实现与Python的列表实现

## 3.2 何谓线性数据结构

栈、队列、双端队列和列表都是<font color="red">**有序的**</font>数据集合.<font color="red">**其元素的顺序取决于添加顺序或移除顺序.**</font>

<font color="red">**线性数据结构:一旦某个元素被添加进来,它与前后元素的相对位置将保持不变.**</font>

线性数据结构可以看做有<font color="red">**两端.**</font>真正区分某个数据结构是否为线性数据结构的是:<font color="red">**元素的添加方式和移除方式,特别是添加操作和移除操作发生的位置.**</font>例如,某个数据结构可能只允许在一端添加新元素,有些则允许从任意一端移除元素.

## 3.3 栈

### 3.3.1 何谓栈

<font color="red">**栈:**</font>栈是<font color="red">**有序集合,且添加操作和移除操作总发生在同一端,**</font>即"顶端",另一端则被称为"底端".

<font color="red">**栈中的元素离底端越近,表示该元素在栈中存在的时间越长.**</font>因此栈的底端有非常重要的含义.

栈的排序原则:<font color="red">**后入先出.即新添加的元素将被最先移除.这种排序原则被称为LIFO(Last-In First-Out).**</font>

栈提出了一种<font color="red">**基于元素存在于集合中的时间来排序的方式.**</font>元素存在于集合中的时间越长,则越靠近底端;反之则靠近顶端.

举一个日常生活中的例子:

我经常买很多书然后又不看,这些书就叠成了一摞.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B9%A6%E6%9E%84%E6%88%90%E7%9A%84%E6%A0%88.jpg)

在这一摞书中,唯一露出封面的书就是顶部的那本.为了拿到其他的某本书,需要移除压在这本书上面的所有书.

观察这一摞书是如何一本一本的码起来的,就能理解栈的重要思想.假设桌面一开始是空的,每次只能往桌上放一本书.如此堆叠,就构建出了一个栈.

而取书的顺序与放书的顺序正好相反:想要取到某本书,则必须先从这一摞书的顶部开始,一次一本的拿走,直到取到自己想拿的那本书为止.而这个过程,也就是拆除了一个栈的过程.

再进一步思考:如果从这一摞书中,自上而下一次一本的拿走,将这些拿走的书再放成另一摞,则构成了另一个栈,且新栈与原栈恰好是逆序的关系.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%A0%88%E7%9A%84%E5%8F%8D%E8%BD%AC--%E4%BB%A5%E4%B9%A6%E4%B8%BA%E4%BE%8B.jpg)

再来看由原生Python数据对象构成的栈:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E7%94%B1%E5%8E%9F%E7%94%9FPython%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E6%9E%84%E6%88%90%E7%9A%84%E6%A0%88.jpg)

那么根据刚刚拿书的例子,我们来看一看<font color="red">**栈的反转特性:**</font>

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%A0%88%E7%9A%84%E5%8F%8D%E8%BD%AC%E7%89%B9%E6%80%A7.jpg)

根据这个特性,可以想到一些在使用计算机时的例子.比如我们在浏览网页时,这些网页的URL就被存放在了一个栈中.当前打开的网页位于栈的最顶端,最早打开的网页位于栈的最低端.点击后退按钮,则开始反向浏览这些网页.

### 3.3.2 栈抽象数据类型

#### a. 栈的特性

- 1. 有序集合
- 2. 添加与移除操作都发生在顶端
- 3. 操作顺序为LIFO

#### b. 栈支持的操作

根据栈的特性,如果我们要自己设计一个栈,应该支持如下的操作;

- 1. Stack():创建一个空栈.该方法不需要参数,返回值为一个空栈.
- 2. push(item):将一个元素添加到栈的顶端.该方法接收一个参数item,无返回值.
- 3. pop():将栈顶端的元素移除.该方法不需要参数,返回值为顶端的元素,且会对栈造成修改.
- 4. peek():查看栈顶端的元素.但并不移除该元素.该方法不需要参数,无返回值,不会对栈造成修改.
- 5. isEmpty():检查栈是否为空.该方法不需要参数,返回值为一个布尔类型,True表示空栈,False表示非空栈.
- 6. size():检查一个栈中元素的数量.该方法不需要参数,且会返回一个整型.

#### c. 栈操作示例

<table border="1px solid black">
    <thead>
    <tr>
        <td>栈操作</td>
        <td>栈内容</td>
        <td>返回值</td>
    </tr>
    </thead>
    <tr>
        <td>stack.isEmpty()</td>
        <td>[]</td>
        <td>True</td>
    </tr>
    <tr>
        <td>stack.push(4)</td>
        <td>[4]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.push('dog')</td>
        <td>[4, 'dog']</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.peek()</td>
        <td>[4, 'dog']</td>
        <td>'dog'</td>
    </tr>
    <tr>
        <td>stack.push(True)</td>
        <td>[4, 'dog', True]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.size()</td>
        <td>[4, 'dog', True]</td>
        <td>3</td>
    </tr>
    <tr>
        <td>stack.isEmpty()</td>
        <td>[4, 'dog', True]</td>
        <td>False</td>
    </tr>
    <tr>
        <td>stack.push(8.4)</td>
        <td>[4, 'dog', True, 8.4]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.pop()</td>
        <td>[4, 'dog', True]</td>
        <td>8.4</td>
    </tr>
    <tr>
        <td>stack.pop()</td>
        <td>[4, 'dog']</td>
        <td>True</td>
    </tr>
    <tr>
        <td>stack.size()</td>
        <td>[4, 'dog']</td>
        <td>2</td>
    </tr>
</table>

### 3.3.3 用Python实现栈

栈是一个有序集合,那么Python中同样是有序集合的数据类型有:

- 列表
- 字符串
- 元组

从这三者中,很明显应该使用列表数据类型来实现栈.在实现时,只需要考虑将列表中的哪一端视为顶端即可.一旦确定了顶端,所有针对栈的操作均可使用list的相关操作来实现.

#### 实现方式A:用list的尾部表示stack的顶部

- a. 该方式的优点:使用list.append()和list.pop()即可实现元素的入栈和出栈.这2个操作的时间复杂度均为O(1).性能好.
- b. 该方式的缺点:不直观.list的排列顺序和stack的顺序相反.

代码如下:

```python
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        if not self.items:
            return True
        else:
            return False

    def push(self, item):
        self.items.append(item)
        return

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            return IndexError("IndexError: pop from empty stack")

    def size(self):
        return len(self.items)

    def peek(self):
        if not self.is_empty():
            return self.items[self.size() - 1]
        else:
            return IndexError("IndexError: stack index out of range")

```

#### 实现方式B:用list的头部表示stack的顶部

- a. 该方式的优点:直观.由于list的头部表示stack的顶部,list的排列顺序和stack的顺序一致.
- b. 该方式的缺点:性能差.使用list的头部表示stack的顶部,则元素入栈需使用`list.insert(0, item)`操作,元素出栈需使用`list.pop(0)`操作,这2个操作的时间复杂度均为O(n).

代码如下:

```python
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        if not self.items:
            return True
        else:
            return False

    def push(self, item):
        self.items.insert(0, item)
        return

    def pop(self):
        if not self.is_empty():
            return self.items.pop(0)
        else:
            return IndexError("IndexError: pop from empty stack")

    def peek(self):
        if not self.is_empty():
            return self.items[0]
        else:
            return IndexError("IndexError: stack index out of range")

    def size(self):
        return len(self.items)

```

### 3.3.4 匹配括号

#### a. 需求

匹配括号:每一个左括号都有与之对应的一个右括号,且括号对有正确的嵌套关系.

例如:

- (()()()())
- ((()))
- (()((()())))

均为正确匹配的括号串.

例如:

- (((((())
- ()))
- (()()()

则不是正确匹配的括号串.

请编写一个算法,该函数从左到右读取一个括号串,并判断其中的括号是否匹配.

#### b. 实现思路

如果仅仅是匹配一个字符串内的'('和')'的个数是否相同,是很好实现的.但是,这个需求要求的是<font color="red">**不仅'('和')'的个数相同,且括号对有正确的嵌套关系.**</font>那么就有可能出现下图中的情况:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%8C%B9%E9%85%8D%E6%8B%AC%E5%8F%B7.jpg)

对于一个<font color="red">**未匹配到')'的'('**</font>而言:

- 若这个'('是整个字符串中的<font color="red">**最后一个**</font>未匹配到')'的'(',则与之匹配的')'必然和之后遇到的第一个')'匹配;
- 若这个'('是整个字符串中<font color="red">**第一个**</font>未匹配到')'的'(',则有可能要等到处理至最后一个位置的')',才能被认为是完成匹配;

匹配的规律,实际上就是一个元素出栈入栈的规律.

- 创建一个空栈,从左到右依次处理括号(即遍历字符串获取每个字符)
- 若当前字符为'(',则压入栈中,表示稍后<font color="red">**可能**</font>会有一个')'与之匹配
- 若当前字符为')',则弹出栈顶的<font color="red">**1个**</font>元素,表示找到了与弹出栈的'('相匹配的')'
- 遍历完毕后若栈仍为空栈,则说明该字符串中的括号是匹配的.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def par_checker(par_string):
    checked_stack = Stack()
    is_balanced = True
    for i in range(0, len(par_string), 1):
        checked_char = par_string[i]
        if checked_char == '(':
            checked_stack.push(checked_char)
        elif checked_char == ')':
            checked_stack.pop()

    if checked_stack.is_empty():
        return is_balanced
    else:
        print(checked_stack.items)
        is_balanced = False
        return is_balanced


print(par_checker("(()()()())"))

```

### 3.3.5 匹配符号

#### a. 需求

匹配符号:每一个左符号都有与之对应的一个右符号,且成对出现的符号有正确的嵌套关系.

例如:

- {{[][]}()}
- [[{{(())}}]]
- [][]\[](){}

均为正确匹配的符号串.

例如:

- ([)]
- ((()]))
- [{()]

则不是正确匹配的符号串.

#### b. 实现思路

基于3.3.4的实现思路,仅需要小小的改动即可:

- a. 遍历待检测字符串
- b. 遇到左符号,入栈
- c. 遇到右符号,出栈
- d. 出栈后比对左符号和右符号是否匹配.(即:当前检测的字符为']',出栈的元素是否为'[')
- e. 若出栈的字符和当前检测的字符匹配,则继续比对下一个字符
- f. 否则,待检测字符串不匹配.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def symbol_checker(par_string):
    checked_stack = Stack()

    is_balanced = True

    for i in range(0, len(par_string), 1):
        checked_char = par_string[i]
        if checked_char in "([{":
            checked_stack.push(checked_char)
        elif checked_char in ")]}":
            right_symbol = checked_stack.pop()
            if is_matches(right_symbol, checked_char):
                continue
            else:
                is_balanced = False
                return is_balanced

    return is_balanced


def is_matches(left_symbol, right_symbol):
    left_chars = "([{"
    right_chars = ")]}"
    return left_chars.index(left_symbol) == right_chars.index(right_symbol)
```

### 3.3.6 十进制数转二进制数

#### a. 需求

请设计一个函数,该函数接收一个十进制的自然数,返回该整数的二进制表示.

#### b. 实现思路

我们找一个十进制正整数,看看它如何转换为二进制数.

以十进制数233为例:

233 = 2 * 10^2 + 3 * 10^1 + 3 * 10^0

233 = 1 * 2^7 + 1* 2^6 + 1 * 2^5 + 0 * 2^4 + 1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0

因此:233的二进制表示为:11101001

如何得出的二进制表示法呢?

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.jpg)

如上图示,使用"除以2"算法.

- a. 该算法是一个简单的循环,不停地将十进制数除以2,并记录余数,直到十进制数小于2(也就是图中的"商为0")为止.
- b. 将每一次除法得出的余数倒序排列,即为该十进制数的二进制表示.

为什么这个算法是这个操作呢?

我们来想一想第一次除法:

- a. 第一次除法得出的余数为0,则该十进制数为偶数,进而可知:该十进制数的二进制表示中,最后一位应该为0
- b. 第一次除法得出的余数为1,则该十进制数为奇数,进而可知:该十进制数的二进制表示中,最后一位应该为1
- c. 第二次除法得出的余数为0,则该十进制数 % 4 为0,进而可知:该十进制数的二进制表示中,倒数第二位应该为0
- d. 第二次除法得出的余数为1,则该十进制数 % 4 为1,进而可知:该十进制数的二进制表示中,倒数第二位应该为1

...

以此类推,当商为0时,即可得出该十进制数的二进制表示中的第1位的值.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack
import math


def convert_decimal_to_binary(decimal):
    division_flag = True
    binary_stack = Stack()
    last_decimal = decimal

    while division_flag:
        quotient = math.floor(last_decimal / 2)
        remainder = last_decimal % 2
        binary_stack.push(remainder)
        last_decimal = quotient
        # 当商 < 进制数 时 不再做除法操作
        if quotient == 0:
            division_flag = False

    binary_str = ""
    for i in range(0, binary_stack.size(), 1):
        binary_str += str(binary_stack.pop())

    return binary_str
```

更精简的代码实现:

```python
def divide_by_2(dec_number):
    rem_stack = Stack()

    while dec_number > 0:
        rem = dec_number % 2
        rem_stack.push(rem)
        # // 在python中表示取整除
        dec_number = dec_number // 2

    bin_str = ""
    while not rem_stack.is_empty():
        bin_str += str(rem_stack.pop())

    return bin_str
```

#### d. 更通用的需求

##### d1. 需求

在计算机科学中,常常还要使用到八进制、十六进制的数字.那么上面的实现就满足不了这种更通用的需求了.因此,此时我们的需求是:

- 请设计一个函数,该函数接收一个十进制的自然数和一个标识进制的数字(假定进制不超过16),返回该自然数的指定进制的表示.

##### d2. 实现思路

我们之前的实现,有2点不满足该需求:

- a. 无法指定进制
- b. 当指定的进制超过10时,不知道该用什么字符表示

无法指定进制的问题相对比较好解决,将函数中的常数换成变量即可.但指定的进制超过10之后无法表示,这个问题就不好解决了.我们可以效仿十六进制的表达方式,<font color="red">**添加一些字母到数字中去**</font>.

在十六进制中:

- a表示10
- b表示11
- c表示12
- ...
- f表示15

#### d3. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def convert_decimal_to_any_scale(decimal, scale_num):
    scale_stack = Stack()
    num_chars = "0123456789ABCDEF"

    while decimal > 0:
        remainder = decimal % scale_num
        scale_stack.push(remainder)
        decimal = decimal // scale_num

    scale_str = ""

    while not scale_stack.is_empty():
        scale_str += num_chars[scale_stack.pop()]

    return scale_str
```



<font color="red">****</font>