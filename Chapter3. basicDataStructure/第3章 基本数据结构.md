# 第3章 基本数据结构

## 3.1 本章目标

- 理解栈、队列、双端队列、列表等抽象数据类型
- 能够使用Python列表实现栈、队列和双端队列
- 理解基础线性数据结构的性能
- 理解前序、中序和后序表达式
- 使用栈来计算后序表达式
- 使用栈将中序表达式转换成后序表达式
- 使用队列进行基本的时序模拟
- 理解栈、队列以及双端队列适用于解决何种问题
- 能够使用"节点与引用"模式将列表实现为列表
- 能够从性能方面比较自己的链表实现与Python的列表实现

## 3.2 何谓线性数据结构

栈、队列、双端队列和列表都是<font color="red">**有序的**</font>数据集合.<font color="red">**其元素的顺序取决于添加顺序或移除顺序.**</font>

<font color="red">**线性数据结构:一旦某个元素被添加进来,它与前后元素的相对位置将保持不变.**</font>

线性数据结构可以看做有<font color="red">**两端.**</font>真正区分某个数据结构是否为线性数据结构的是:<font color="red">**元素的添加方式和移除方式,特别是添加操作和移除操作发生的位置.**</font>例如,某个数据结构可能只允许在一端添加新元素,有些则允许从任意一端移除元素.

## 3.3 栈

### 3.3.1 何谓栈

<font color="red">**栈:**</font>栈是<font color="red">**有序集合,且添加操作和移除操作总发生在同一端,**</font>即"顶端",另一端则被称为"底端".

		注:此处的集合不是数学上集合的概念.因为数学定义的集合,是不允许重复元素出现的.

<font color="red">**栈中的元素离底端越近,表示该元素在栈中存在的时间越长.**</font>因此栈的底端有非常重要的含义.

栈的排序原则:<font color="red">**后入先出.即新添加的元素将被最先移除.这种排序原则被称为LIFO(Last-In First-Out).**</font>

栈提出了一种<font color="red">**基于元素存在于集合中的时间来排序的方式.**</font>元素存在于集合中的时间越长,则越靠近底端;反之则靠近顶端.

举一个日常生活中的例子:

我经常买很多书然后又不看,这些书就叠成了一摞.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B9%A6%E6%9E%84%E6%88%90%E7%9A%84%E6%A0%88.jpg)

在这一摞书中,唯一露出封面的书就是顶部的那本.为了拿到其他的某本书,需要移除压在这本书上面的所有书.

观察这一摞书是如何一本一本的码起来的,就能理解栈的重要思想.假设桌面一开始是空的,每次只能往桌上放一本书.如此堆叠,就构建出了一个栈.

而取书的顺序与放书的顺序正好相反:想要取到某本书,则必须先从这一摞书的顶部开始,一次一本的拿走,直到取到自己想拿的那本书为止.而这个过程,也就是拆除了一个栈的过程.

再进一步思考:如果从这一摞书中,自上而下一次一本的拿走,将这些拿走的书再放成另一摞,则构成了另一个栈,且新栈与原栈恰好是逆序的关系.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%A0%88%E7%9A%84%E5%8F%8D%E8%BD%AC--%E4%BB%A5%E4%B9%A6%E4%B8%BA%E4%BE%8B.jpg)

再来看由原生Python数据对象构成的栈:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E7%94%B1%E5%8E%9F%E7%94%9FPython%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E6%9E%84%E6%88%90%E7%9A%84%E6%A0%88.jpg)

那么根据刚刚拿书的例子,我们来看一看<font color="red">**栈的反转特性:**</font>

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%A0%88%E7%9A%84%E5%8F%8D%E8%BD%AC%E7%89%B9%E6%80%A7.jpg)

根据这个特性,可以想到一些在使用计算机时的例子.比如我们在浏览网页时,这些网页的URL就被存放在了一个栈中.当前打开的网页位于栈的最顶端,最早打开的网页位于栈的最低端.点击后退按钮,则开始反向浏览这些网页.

### 3.3.2 栈抽象数据类型

#### a. 栈的特性

- 1. 有序集合
- 2. 添加与移除操作都发生在顶端
- 3. 操作顺序为LIFO

#### b. 栈支持的操作

根据栈的特性,如果我们要自己设计一个栈,应该支持如下的操作;

- 1. Stack():创建一个空栈.该方法不需要参数,返回值为一个空栈.
- 2. push(item):将一个元素添加到栈的顶端.该方法接收一个参数item,无返回值.
- 3. pop():将栈顶端的元素移除.该方法不需要参数,返回值为顶端的元素,且会对栈造成修改.
- 4. peek():查看栈顶端的元素.但并不移除该元素.该方法不需要参数,无返回值,不会对栈造成修改.
- 5. is_empty():检查栈是否为空.该方法不需要参数,返回值为一个布尔类型,True表示空栈,False表示非空栈.
- 6. size():检查一个栈中元素的数量.该方法不需要参数,且会返回一个整型.

#### c. 栈操作示例

<table border="1px solid black">
    <thead>
    <tr>
        <td>栈操作</td>
        <td>栈内容</td>
        <td>返回值</td>
    </tr>
    </thead>
    <tr>
        <td>stack.isEmpty()</td>
        <td>[]</td>
        <td>True</td>
    </tr>
    <tr>
        <td>stack.push(4)</td>
        <td>[4]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.push('dog')</td>
        <td>[4, 'dog']</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.peek()</td>
        <td>[4, 'dog']</td>
        <td>'dog'</td>
    </tr>
    <tr>
        <td>stack.push(True)</td>
        <td>[4, 'dog', True]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.size()</td>
        <td>[4, 'dog', True]</td>
        <td>3</td>
    </tr>
    <tr>
        <td>stack.is_empty()</td>
        <td>[4, 'dog', True]</td>
        <td>False</td>
    </tr>
    <tr>
        <td>stack.push(8.4)</td>
        <td>[4, 'dog', True, 8.4]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.pop()</td>
        <td>[4, 'dog', True]</td>
        <td>8.4</td>
    </tr>
    <tr>
        <td>stack.pop()</td>
        <td>[4, 'dog']</td>
        <td>True</td>
    </tr>
    <tr>
        <td>stack.size()</td>
        <td>[4, 'dog']</td>
        <td>2</td>
    </tr>
</table>

### 3.3.3 用Python实现栈

栈是一个有序集合,那么Python中同样是有序集合的数据类型有:

- 列表
- 字符串
- 元组

从这三者中,很明显应该使用列表数据类型来实现栈.在实现时,只需要考虑将列表中的哪一端视为顶端即可.一旦确定了顶端,所有针对栈的操作均可使用list的相关操作来实现.

#### 实现方式A:用list的尾部表示stack的顶部

- a. 该方式的优点:使用list.append()和list.pop()即可实现元素的入栈和出栈.这2个操作的时间复杂度均为O(1).性能好.
- b. 该方式的缺点:不直观.list的排列顺序和stack的顺序相反.

代码如下:

```python
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        if not self.items:
            return True
        else:
            return False

    def push(self, item):
        self.items.append(item)
        return

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            return IndexError("IndexError: pop from empty stack")

    def size(self):
        return len(self.items)

    def peek(self):
        if not self.is_empty():
            return self.items[self.size() - 1]
        else:
            return IndexError("IndexError: stack index out of range")

```

#### 实现方式B:用list的头部表示stack的顶部

- a. 该方式的优点:直观.由于list的头部表示stack的顶部,list的排列顺序和stack的顺序一致.
- b. 该方式的缺点:性能差.使用list的头部表示stack的顶部,则元素入栈需使用`list.insert(0, item)`操作,元素出栈需使用`list.pop(0)`操作,这2个操作的时间复杂度均为O(n).

代码如下:

```python
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        if not self.items:
            return True
        else:
            return False

    def push(self, item):
        self.items.insert(0, item)
        return

    def pop(self):
        if not self.is_empty():
            return self.items.pop(0)
        else:
            return IndexError("IndexError: pop from empty stack")

    def peek(self):
        if not self.is_empty():
            return self.items[0]
        else:
            return IndexError("IndexError: stack index out of range")

    def size(self):
        return len(self.items)

```

### 3.3.4 匹配括号

#### a. 需求

匹配括号:每一个左括号都有与之对应的一个右括号,且括号对有正确的嵌套关系.

例如:

- (()()()())
- ((()))
- (()((()())))

均为正确匹配的括号串.

例如:

- (((((())
- ()))
- (()()()

则不是正确匹配的括号串.

请编写一个算法,该函数从左到右读取一个括号串,并判断其中的括号是否匹配.

#### b. 实现思路

如果仅仅是匹配一个字符串内的'('和')'的个数是否相同,是很好实现的.但是,这个需求要求的是<font color="red">**不仅'('和')'的个数相同,且括号对有正确的嵌套关系.**</font>那么就有可能出现下图中的情况:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%8C%B9%E9%85%8D%E6%8B%AC%E5%8F%B7.jpg)

对于一个<font color="red">**未匹配到')'的'('**</font>而言:

- 若这个'('是整个字符串中的<font color="red">**最后一个**</font>未匹配到')'的'(',则与之匹配的')'必然和之后遇到的第一个')'匹配;
- 若这个'('是整个字符串中<font color="red">**第一个**</font>未匹配到')'的'(',则有可能要等到处理至最后一个位置的')',才能被认为是完成匹配;

匹配的规律,实际上就是一个元素出栈入栈的规律.

- 创建一个空栈,从左到右依次处理括号(即遍历字符串获取每个字符)
- 若当前字符为'(',则压入栈中,表示稍后<font color="red">**可能**</font>会有一个')'与之匹配
- 若当前字符为')',则弹出栈顶的<font color="red">**1个**</font>元素,表示找到了与弹出栈的'('相匹配的')'
- 遍历完毕后若栈仍为空栈,则说明该字符串中的括号是匹配的.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def par_checker(par_string):
    checked_stack = Stack()
    is_balanced = True
    for i in range(0, len(par_string), 1):
        checked_char = par_string[i]
        if checked_char == '(':
            checked_stack.push(checked_char)
        elif checked_char == ')':
            checked_stack.pop()

    if checked_stack.is_empty():
        return is_balanced
    else:
        print(checked_stack.items)
        is_balanced = False
        return is_balanced


print(par_checker("(()()()())"))

```

### 3.3.5 匹配符号

#### a. 需求

匹配符号:每一个左符号都有与之对应的一个右符号,且成对出现的符号有正确的嵌套关系.

例如:

- {{[][]}()}
- [[{{(())}}]]
- [][]\[](){}

均为正确匹配的符号串.

例如:

- ([)]
- ((()]))
- [{()]

则不是正确匹配的符号串.

#### b. 实现思路

基于3.3.4的实现思路,仅需要小小的改动即可:

- a. 遍历待检测字符串
- b. 遇到左符号,入栈
- c. 遇到右符号,出栈
- d. 出栈后比对左符号和右符号是否匹配.(即:当前检测的字符为']',出栈的元素是否为'[')
- e. 若出栈的字符和当前检测的字符匹配,则继续比对下一个字符
- f. 否则,待检测字符串不匹配.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def symbol_checker(par_string):
    checked_stack = Stack()

    is_balanced = True

    for i in range(0, len(par_string), 1):
        checked_char = par_string[i]
        if checked_char in "([{":
            checked_stack.push(checked_char)
        elif checked_char in ")]}":
            right_symbol = checked_stack.pop()
            if is_matches(right_symbol, checked_char):
                continue
            else:
                is_balanced = False
                return is_balanced

    return is_balanced


def is_matches(left_symbol, right_symbol):
    left_chars = "([{"
    right_chars = ")]}"
    return left_chars.index(left_symbol) == right_chars.index(right_symbol)
```

### 3.3.6 十进制数转二进制数

#### a. 需求

请设计一个函数,该函数接收一个十进制的自然数,返回该整数的二进制表示.

#### b. 实现思路

我们找一个十进制正整数,看看它如何转换为二进制数.

以十进制数233为例:

233 = 2 * 10^2 + 3 * 10^1 + 3 * 10^0

233 = 1 * 2^7 + 1* 2^6 + 1 * 2^5 + 0 * 2^4 + 1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0

因此:233的二进制表示为:11101001

如何得出的二进制表示法呢?

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.jpg)

如上图示,使用"除以2"算法.

- a. 该算法是一个简单的循环,不停地将十进制数除以2,并记录余数,直到十进制数小于2(也就是图中的"商为0")为止.
- b. 将每一次除法得出的余数倒序排列,即为该十进制数的二进制表示.

为什么这个算法是这个操作呢?

我们来想一想第一次除法:

- a. 第一次除法得出的余数为0,则该十进制数为偶数,进而可知:该十进制数的二进制表示中,最后一位应该为0
- b. 第一次除法得出的余数为1,则该十进制数为奇数,进而可知:该十进制数的二进制表示中,最后一位应该为1
- c. 第二次除法得出的余数为0,则该十进制数 % 4 为0,进而可知:该十进制数的二进制表示中,倒数第二位应该为0
- d. 第二次除法得出的余数为1,则该十进制数 % 4 为1,进而可知:该十进制数的二进制表示中,倒数第二位应该为1

...

以此类推,当商为0时,即可得出该十进制数的二进制表示中的第1位的值.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack
import math


def convert_decimal_to_binary(decimal):
    division_flag = True
    binary_stack = Stack()
    last_decimal = decimal

    while division_flag:
        quotient = math.floor(last_decimal / 2)
        remainder = last_decimal % 2
        binary_stack.push(remainder)
        last_decimal = quotient
        # 当商 < 进制数 时 不再做除法操作
        if quotient == 0:
            division_flag = False

    binary_str = ""
    for i in range(0, binary_stack.size(), 1):
        binary_str += str(binary_stack.pop())

    return binary_str
```

更精简的代码实现:

```python
def divide_by_2(dec_number):
    rem_stack = Stack()

    while dec_number > 0:
        rem = dec_number % 2
        rem_stack.push(rem)
        # // 在python中表示取整除
        dec_number = dec_number // 2

    bin_str = ""
    while not rem_stack.is_empty():
        bin_str += str(rem_stack.pop())

    return bin_str
```

#### d. 更通用的需求

##### d1. 需求

在计算机科学中,常常还要使用到八进制、十六进制的数字.那么上面的实现就满足不了这种更通用的需求了.因此,此时我们的需求是:

- 请设计一个函数,该函数接收一个十进制的自然数和一个标识进制的数字(假定进制不超过16),返回该自然数的指定进制的表示.

##### d2. 实现思路

我们之前的实现,有2点不满足该需求:

- a. 无法指定进制
- b. 当指定的进制超过10时,不知道该用什么字符表示

无法指定进制的问题相对比较好解决,将函数中的常数换成变量即可.但指定的进制超过10之后无法表示,这个问题就不好解决了.我们可以效仿十六进制的表达方式,<font color="red">**添加一些字母到数字中去**</font>.

在十六进制中:

- a表示10
- b表示11
- c表示12
- ...
- f表示15

#### d3. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def convert_decimal_to_any_scale(decimal, scale_num):
    scale_stack = Stack()
    num_chars = "0123456789ABCDEF"

    while decimal > 0:
        remainder = decimal % scale_num
        scale_stack.push(remainder)
        decimal = decimal // scale_num

    scale_str = ""

    while not scale_stack.is_empty():
        scale_str += num_chars[scale_stack.pop()]

    return scale_str
```

### 3.3.7 前序、中序和后序表达式

#### a. 简介

<font color="red">**中序表达式:**</font>运算符出现在2个操作数<font color="red">**中间**</font>的表达式,被称为中序表达式.

例如:像`B * C`这样的算术表达式,可以根据其结构来进行正确的运算.在`B * C`中,由于乘号`*`出现在两个变量之间,因此我们知道应该用变量B乘以变量C.

再来看另外一个中序表达式的例子:`A + B * C`,虽然运算符`+`和运算符`*`都在操作数之间,但是有几个问题:

- 这两个符号分别用于哪些操作数?
- `+`是否作用于A和B?
- `*`是否作用于B和C?

这个表达式看起来是有歧义的.

实际上我们经常读写这类表达式,并没有遇到任何问题.这是因为我们知道`+`和`*`的特点.每一个运算符都有一个<font color="red">**优先级.**</font><font color="red">**在运算时,高优先级的运算符先于低优先级的运算符.唯一能够改变运算顺序的就是括号.若两个运算符的优先级相同,则按照从左到右或者结合律的顺序进行运算.**</font>

从运算符优先级的角度来理解`A = B * C`:

- step1. 计算 `B * C`
- step2. 计算 `A + 乘积`

从运算符优先级的角度来理解`(A + B) * C`:

- step1. 计算`A + B`
- step2. 计算`和 * C`

从运算符优先级的角度来理解`A + B + C`:

- step1. 计算`A + B`
- step2. 计算`和 + C`

那么问题来了:这种规律对于人来讲,显而易见,但是计算机来处理这个问题,就必须定义明确规则了.一种杜绝歧义的写法是<font color="red">**完全括号表达式.这种表达式对每一个运算符都添加一对括号,由括号来决定运算的顺序,没有任何歧义,且不需要定义任何的优先级规则.**</font>

例如:`A + B * C + D`可以被重写成`((A + (B * C)) + D)`,用以表明:

- step1. 计算`B * C`
- step2. 计算`A + 乘积`
- step3. 计算`和 + D`

例如:`A + B + C + D`可以被重写成`(((A + B) + C) + D)`,用以表明:

- step1. 计算`A + B`
- step2. 计算`和 + C`
- step3. 计算`和 + D`

还有另外2种重要的表达式,可能不太能够做到一目了然地看出它们的含义:

<font color="red">**前序表达式:**</font>运算符出现在2个操作数<font color="red">**之前**</font>的表达式,被称为前序表达式.

例如:`+ A B`

实际上这种表达式也被应用于编程语言中,如LISP:

```LISP
(defun square(n)
	(* n n))
```

这段代码定义了一个名为square的函数.该函数会返回参数n的平方.

<font color="red">**后序表达式:**</font>运算符出现在2个操作数<font color="red">**后边**</font>的表达式,被称为后序表达式.

例如:`A B +`

中序、前序与后序表达式:

<table border="1px solid black">
    <thead>
    <tr>
        <td colspan="3">中序、前序与后序表达式</td>
    </tr>
    </thead>
    <tr>
        <td>中序表达式</td>
        <td>前序表达式</td>
        <td>后序表达式</td>
    </tr>
    <tr>
        <td>A + B</td>
        <td>+ A B</td>
        <td>A B +</td>
    </tr>
    <tr>
        <td>A + B * C</td>
        <td>+ A * B C</td>
        <td>A B C * +</td>
    </tr>
</table>

前序表达式和后序表达式通过运算符的优先级来确保正确的运算顺序.例如:

- `A + B * C`转换为前序表达式为`+ A * B C`,`*`出现在B和C之前,表示`*`的优先级高于`+`.进而`+`出现在A和乘法结果之前.
- `A + B * C`转换为后序表达式为`A B C * +`.`*`出现在B和C之后,表示`*`的优先级高于`+`.进而`+`出现在A和乘法结果之后.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B8%AD%E5%BA%8F%E3%80%81%E5%89%8D%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

那么,对于带有括号的中序表达式,例如`(A + B) * C`,它的中序、前序与后续表达式该怎么写?

<table border="1px solid black">
    <thead>
    <tr>
        <td colspan="3">中序、前序与后序表达式</td>
    </tr>
    </thead>
    <tr>
        <td>中序表达式</td>
        <td>前序表达式</td>
        <td>后序表达式</td>
    </tr>
    <tr>
        <td>(A + B) * C</td>
        <td>* + A B C</td>
        <td>A B + C *</td>
    </tr>
</table>

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%94%B9%E5%8F%98%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%B8%AD%E5%BA%8F%E3%80%81%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

注意:`(A + B) * C`的后序表达式只能是`A B + C *`,不能是`C A B + *`,二者虽然计算后的值是相同的,但后者表示的中序表达式是`C * (A + B)`

中序、前序与后序表达式示例

<table border="1px solid black">
    <thead>
    <tr>
        <td colspan="3">中序、前序与后序表达式示例</td>
    </tr>
    </thead>
    <tr>
        <td>中序表达式</td>
        <td>前序表达式</td>
        <td>后序表达式</td>
    </tr>
    <tr>
        <td>A + B * C + D</td>
        <td>+ + A * B C D</td>
        <td>A B C * + D +</td>
    </tr>
    <tr>
        <td>(A + B) * (C + D)</td>
        <td>* + A B + C D</td>
        <td>A B + C D + *</td>
    </tr>
    <tr>
        <td>A * B + C * D</td>
        <td>+ * A B * C D</td>
        <td>A B * C D * +</td>
    </tr>
    <tr>
        <td>A + B + C + D</td>
        <td>+ + + A B C D</td>
        <td>A B + C + D +</td>
    </tr>
</table>

#### b. 从中序向前序和后序转换

存在通用的算法,可用于正确转换任意复杂度的表达式.

首先使用完全括号表达式.上文中说过,可以将`A + B * C`写作`(A + (B * C))`,以便表示`*`的优先级高于`+`.<font color="red">**在完全括号表达式中,每对括号都对应着一个中序表达式(包含2个操作数以及这2个操作数中间的运算符).**</font>

对于一个中序表达式,无论其多么的复杂,均可按照如下步骤,转化为一个后序表达式:

- step1. 将`*`挪动到`)`的位置上
- step2. 将`)`对应的`(`删除
- step3. 将`+`挪动到`)`的位置上
- step4. 将对应的`(`删除

即可得到一个中序表达式对应的后序表达式.

具体转换过程如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

同样的,对于一个中序表达式,按照如下步骤,即可转化为一个前序表达式:

- step1. 将`*`挪动到`(`的位置上
- step2. 将对应的`)`删除
- step3. 将`+`挪动到`(`的位置上
- step4. 将对应的`)`删除

具体转换过程如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%89%8D%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

一个复杂一点的例子:(A + B) * C - (D - E) * (F + G)

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%89%8D%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

最终结果如下:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E5%89%8D%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

#### c. 从中序到后序的通用转换法

##### c1. 需求

需求:<font color="red">**请设计一个函数,该函数可以将任意中序表达式转换为后序表达式.**</font>

- a. 该函数接收一个以<font color="red">**字符串形式**</font>表示的中序表达式.
- b. 该字符串以空格为分隔符
- c. 该中序表达式中仅含有`+ - * /`四种操作符
- d. 该中序表达式中可能含有`()`
- e. 该函数的返回值为该中序表达式的后序表达式

##### c2. 不带括号的中序表达式改写为后序表达式的过程

我们再来看`A + B * C`的例子.其后序表达式为`A B C * +`.我们发现无论是将一个中序表达式转换为前序还是后序表达式,转换后的表达式,操作数的相对位置均不发生改变.改变的只有操作符的位置.再来看中序表达式中运算符的位置与计算顺序:

- 位置:从左往右看,先出现`+`再出现`*`
- 计算顺序:先计算`*`再计算`+`

我们发现操作符的计算顺序和后序表达式中操作符的出现顺序是一样的,但和中序表达式中操作符的出现顺序是<font color="red">**相反**</font>的.

在转换的过程中,因为运算符右边的操作数还没有出现,因而需要将运算符保存在某处.例如:`A + B`

-  1. 看到A
-  2. 看到`+`,保存起来,继续看下一个字符
-  3. 看到B
-  4. 此时,`A + B`才是<font color="red">**可计算的**</font>

这才是我们需要暂时将运算符保存起来的原因.

进而看一个更复杂的例子:`A + B * C`

- 1. 看到A
- 2. 看到`+`保存起来,继续看下一个字符
- 3. 看到B

但是,此时并不能计算`A + B`,因为右边有一个运算优先级高于`+`的操作符`*`

- 4. 看到`*`保存起来,继续看下一个字符
- 5. 看到`C`
- 6. 此时,`B * C`成为一个<font color="red">**可计算的表达式**</font>
- 7. 进而,`A + B * C`成为一个<font color="red">**可计算的表达式**</font>

至此,我们可以得出结论:<font color="red">**只有当一个优先级较高的运算符完成计算后,其左侧的优先级较低的运算符才可计算.**</font>

##### c3. 带有括号的中序表达式改写为后序表达式的过程

对于`(A + B) * C`,其后序表达式为`A B + C *`.同样地,操作数的相对位置没有发生改变.但由于`()`的出现,改变了操作符的运算优先级,使得在后序表达式中,`+`出现在了`*`前面.按照从左向右看的顺序,我们来分析这个表达式的计算过程:

- 1. 看到`(`,保存起来,继续看下一个字符
- 2. 看到A
- 3. 看到`+`,保存起来,继续看下一个字符
- 4. 看到B
- 5. 看到`)`

此时,这个`)`的出现,就是一种标识:标识着2件事:

    - a. 即将出现一个操作符,该操作符的运算优先级高于括号内的操作符
    - b. `()`内的表达式需要计算

因此,后续步骤为:

- 6. 计算`()`内的表达式(本例中即为`A + B`)
- 7. 看到`*`,保存起来,继续看下一个字符
- 8. 看到`C`
- 9. 此时,`(A + B) * C`成为了一个<font color="red">**可计算的表达式**</font>

##### c4. 实现思路

###### 问题1:使用何种数据结构来处理该需求最为合适?

根据c2和c3两个部分的思考,我们整理出了3个点:

- a. 转换的过程中需要<font color="red">**将运算符暂时保存起来,当该运算符可计算时,再取出该运算符并计算.**</font>

- b. 同时,由于运算符优先级的影响,还有可能存在<font color="red">**后出现的运算符先运算,即:运算顺序与出现顺序相反**</font>的情况.
- c. <font color="red">**`()`的出现会改变操作符的计算优先级.**</font>

在这3个点中,我们发现关键字是<font color="red">**暂存**</font>和<font color="red">**顺序相反**</font>.这2个关键字是<font color="red">**栈的特性.**</font>因此,<font color="red">**这个需求应该使用栈来暂存操作符和`()`**</font>

###### 问题2:具体步骤该怎么做?

根据上边的几个例子,我们可以总结出算法的大致步骤:

- step1. 遍历字符串,取其中的每一个字符
- step2. 分类讨论:
	
	若该字符为<font color="red">**操作数,**</font>则追加到结果列表尾部.继续遍历下一个字符;
	
	若该字符为<font color="red">**操作符,**</font>则继续分类讨论:
		
		若此时栈为空,则直接将该操作符压入栈内,继续遍历下一个字符
		若此时栈不为空,则:
			若栈顶操作符的运算优先级低于当前操作符,则直接将该操作符压入栈内,继续遍历下一个字符
			若栈顶操作符的运算优先级高于或等于当前操作符,则:
				①. 从栈内弹出元素,直到栈顶操作符的运算优先级低于当前操作符
				②. 把当前操作符压入栈内
						
	若该字符为<font color="red">**`(`**</font>,则压入栈中,继续遍历下一个字符;
	
	若该字符为<font color="red">**`)`**</font>,则从栈内弹出元素,直到弹出的值为`(`为止,并将弹出的所有元素(除`(`外)追加到结果列表中,然后遍历下一个字符;
	
		需要注意的是:按上述规则,对于一个)而言,与其匹配的(一定为最先从栈中弹出的那个(.实际上这也是顺序相反的一种体现.
		
	若遍历到了字符串结尾,则将栈中所有的操作符一一弹出,并按弹出顺序追加至结果列表尾部.
	
以`A * B + C * D`为例,演示上述过程:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%BC%94%E7%A4%BA.jpg)

###### 问题3:如何表示运算符的优先级?

可以使用一个字典,该字典将每个运算符映射为一个整数,以该整数的大小表示运算符优先级的高低.<font color="red">**其中`(`的优先级最低,可以把它理解为一个调整操作符优先级的标志.**</font>

##### c5. 实现

```python
import string
from listTailToRepresentStackTop import Stack


def convert_infix_to_epilogue(infix):
    infix = infix.split()

    # 优先级字典
    priority = {
        "*": 3,
        "/": 3,
        "+": 2,
        "-": 2,
        "(": 1
    }

    # 暂存操作符的栈
    operators = Stack()

    # 后序表达式字符列表
    epilogue = []

    for char in infix:
        if char in string.ascii_uppercase:
            # 操作数直接追加至后续表达式列表结尾
            epilogue.append(char)
        else:
            if char == '(':
                # ( 直接压入栈内
                operators.push(char)
            elif char == ')':
                # ) 从栈内弹出元素 直到弹出的元素为(为止 并将这些弹出的操作符追加到结果列表中
                operator = operators.pop()
                while operator != '(':
                    epilogue.append(operator)
                    operator = operators.pop()
            elif operators.is_empty():
                # 栈为空 则将当前运算符直接压入栈内
                operators.push(char)
            else:
                if priority[operators.peek()] < priority[char]:
                    # 栈不为空 且栈顶操作符的优先级低于当前操作符 直接将当前操作符压入栈内
                    operators.push(char)
                else:
                    # 栈不为空 且栈顶操作符的优先级高于或等于当前运算符
                    # 先将栈内所有运算优先级高于或等于当前运算符的运算符弹出 追加到结果列表尾部
                    # 再将当前运算符压入栈内
                    if priority[operators.peek()] >= priority[char]:
                        epilogue.append(operators.pop())
                    else:
                        operators.push(char)

    # 遍历结束 如栈内还有操作符 则弹出并追加到结果列表尾部
    # 因为遍历已经结束了 所以必然在栈内不会有( 因此不用判断
    while not operators.is_empty():
        # print(operators.items)
        epilogue.append(operators.pop())

    return " ".join(epilogue)
```

#### d. 从后序到中序的通用转换法

##### d1. 需求

请设计一个函数,<font color="red">**该函数接收一个后序表达式,该函数可以计算一个后序表达式的值.**</font>

- a. 该函数接收一个以<font color="red">**字符串形式**</font>表达的后序表达式
- b. 该字符串以<font color="red">**空格**</font>为分隔符
- c. 该后序表达式中仅含有`+ - * /`四种操作符
- d. 该后序表达式中的操作数全部为<font color="red">**自然数**</font>
- e. 该函数的返回值为该后续表达式计算后的值

##### d2. 实现思路

###### 问题1:以一个例子分析问题

以后序表达式`4 5 6 * +`为例.还是从左向右看,则有如下步骤:

- step1. 看到<font color="red">**操作数`4`**</font>,因为此时不知道要对该操作数做何种操作(即不知道操作符),所以先暂存在某个地方,等需要用时再取.
- step2. 看到<font color="red">**操作数`5`**</font>,暂存.理由同上
- step3. 看到<font color="red">**操作数`6`**</font>,暂存.理由同上
- step4. 看到<font color="red">**操作数`*`**</font>,则此时<font color="red">**从`*`的位置从右向左找,**</font>找到<font color="red">**距离`*`最近的2个操作数**</font>,实际上这2个数就是最后2次暂存的操作数.
- step5. 则此时一个最基本的表达式就构成了,计算该表达式的值,并用这个值替换原后序表达式中的操作数和操作符的位置.

		例:在本例中,即为 5 6 *.一个表达式构成了,就意味着该表达式从不可计算的状态转化为可计算的状态了.
		① 5 6 * 使用中序表达式来表达的话就是:5 * 6,该表达式的值为30
		② 用30替换原表达式中5 6 * 这3个字符的位置
		③ 此时替换后的表达式为 4 30 +

- step6. 看到<font color="red">**`+`**</font>,则此时<font color="red">**从`+`的位置从右向左找,**</font>找到<font color="red">**距离`*`最近的2个操作数**</font>
- step7. 此时又构成了一个最基本的表达式,计算该表达式的值.由于遍历已经结束,因此该值即为最终结果.

###### 问题2:实现步骤

- step1. 创建空栈
- step2. 将后序表达式转换为列表
- step3. 从左向右扫描标记列表
- step4. 若标记为操作数,则将其转换为一个float,压入栈内,
- step5. 若标记为操作符,则从栈内弹出2个操作数.第一次弹出右操作数,第二次弹出左操作数.进行相应的算术运算.
- step6. 将运算结果压入栈内
- step7. 当表达式处理完毕时,栈内仅有1个元素,这个元素就是表达式的结果.

###### 问题3:解决的步骤中暴露出的特性以及根据该特性应该选取何种数据结构

在这个过程中我们发现:<font color="red">**对操作数的操作顺序和操作数的出现顺序是相反的.**</font>操作数的操作顺序是`4->5->6`,但我们的操作顺序是先计算`5 * 6`,再计算`4 + 30`.

注意,在后序表达式中,对一个操作符和<font color="red">**从该操作符的位置从右向左找,找到的距离该操作符最近的2个**</font>操作数来讲,其运算规则为:

		距操作符较远的操作数 操作符 距操作符较近的操作数
		
举例来讲,后序表达式`6 3 /`,转化为中序表达式,应该是`6 / 3`,而非`3 / 6`.

那么我们来总结这个需求的特点:

- 1. 需要暂存操作数或可计算的表达式的计算结果(实际上这个计算结果要么是最终结果,要么是另一个操作符的操作数)
- 2. 先看到的操作数后操作,因此需要反转顺序.

根据这2个特点,解决这个问题适合的数据结构为:<font color="red">**stack**</font>

那么根据这个结论,上文中的例子,应该按如下步骤解决:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.jpg)

###### 问题4:判断一个计算后的值该如何操作

到了这个步骤,要解决的只差最后一个问题了:<font color="red">**如何得知一个计算后的值该压入栈内还是该作为结果返回?**</font>

这个问题比较简单,<font color="red">**当遍历到后序表达式的最后一个字符时,计算后的值应该返回;否则应该压入栈内等待下一次运算.**</font>

##### d3. 实现

```python
from listTailToRepresentStackTop import Stack

"""
计算一个后序表达式的值
"""


def calc_postfix_expr(postfix_expr):
    postfix_expr = postfix_expr.split()

    # 保存操作数的栈
    operands = Stack()

    for i in range(0, len(postfix_expr), 1):
        token = postfix_expr[i]

        # 判断token是否为操作数
        try:
            token = float(token)
            is_operand = True
        except ValueError:
            is_operand = False

        if is_operand:
            # 操作数直接压入栈
            operands.push(token)
        else:
            # 操作符则需要从栈内弹出2个操作数
            # 先弹出的放在操作符的右边
            # 后弹出的放在操作符的左边
            operand_right, operand_left = operands.pop(), operands.pop()

            # 创建临时表达式并计算临时表达式的值
            tmp_value = eval(str(operand_left) + str(token) + str(operand_right))

            if i == len(postfix_expr) - 1:
                return tmp_value
            else:
                operands.push(tmp_value)

```

## 3.4 队列

接下来学习另一个线性数据结构:队列.

### 3.4.1 何谓队列

队列:<font color="red">**有序**</font>集合,<font color="red">**添加操作发生在"尾部",移除操作发生在"头部".**</font>新元素从尾部被添加到队列中,然后一直向前移动到头部,直到成为下一个被移出的元素.

最后添加的元素必须在队列尾部等待,在队列中时间最长的元素则排在最前面.这种排序原则被称为<font color="red">**FIFO(first-in first-out),**</font>即先进先出,也称先到先得.

在生活中队列的例子其实很常见.排队买票,排队结账,排队喝starfucks.一个维护良好的队列,只允许从队列的一端进入,从队列的另一端离开.不可能发生插队或者中途离开的情况.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

操作系统使用一些队列来控制计算机进程.调度机制基于一个队列算法,使得操作系统尽可能快地执行程序,且能够服务尽可能多的用户.在打字时,有时会看到"字符出现的速度慢于击键速度"的现象.这就是由于操作系统正在处理其他的进程.击键操作就被放入了一个类似于队列的缓冲区,以便对应的字符按正确的顺序显示.

### 3.4.2 队列抽象数据类型

#### a. 队列的特性

- 1. 有序集合
- 2. 添加操作发生在尾部,移除操作发生在头部.
- 3. 操作顺序为FIFO

#### b. 队列支持的操作

- 1. Queue():创建一个空队列,该方法不需要参数,返回值为一个空队列.
- 2. enqueue(item):将一个元素添加到队尾.该方法接收一个item作为参数,无返回值.
- 3. dequeue():将队列头部的元素移除.该方法不需要参数,返回值为位于队列头部的元素,且会对队列造成修改.
- 4. is_empty():检查队列是否为空.该方法不需要参数,返回值为一个布尔类型.True表示空队列,False表示非空队列.
- 5. size():检查一个队列中元素的数量.该方法不需要参数,且会返回一个整型.

#### c. 队列操作示例

队列操作 | 队列内容 | 返回值
:-: | :-: | :-:|
queue.is_empty() | [] | True
queue.enqueue(4) | [4] | 无
queue.enqueue('dog') | ['dog', 4] | 无
queue.enqueue(True) | [True, 'dog', 4] | 无
queue.size() | [True, 'dog', 4] | 3
queue.is_empty() | [True, 'dog', 4] | False
queue.enqueue(8.4) | [8.4, True, 'dog', 4] | 无
queue.dequeue() | [8.4, True, 'dog'] | 4
queue.dequeue() | [8.4, True] | 'dog'
queue.size() | [8.4, True] | 2

### 3.4.3 用Python实现队列

和栈相似,队列也是一个有序集合.那么Python的内置数据类型中,同样是有序集合的数据类型有:

- 列表
- 字符串
- 元组

很明显,还是列表作为队列的底层是最合适的.

下一个要考量的问题就是如何实现更高效了.这个问题的本质在于如下2个实现方案的比对:

- 方案1: 使用列表的头部作为队列的头部,使用列表的尾部作为队列的尾部
- 方案2: 使用列表的头部作为队列的尾部,使用列表的尾部作为队列的头部

想要确定这2个方案哪个更好,就要分析两者的时间复杂度.

使用列表的头部作为队列的头部,使用列表的尾部作为队列的尾部:

		则移除操作的时间复杂度是O(n),添加操作的时间复杂度是O(1)
		
使用列表的头部作为队列的尾部,使用列表的尾部作为队列的头部

		则移除操作的时间复杂度是O(1),添加操作的时间复杂度是O(n)
		

综上所述:

- **若添加操作较多,移除操作较少,则采用"使用列表的头部作为队列的头部,使用列表的尾部作为队列的尾部"的方案效果较好**
- **若移除操作较多,添加操作较少,则采用"使用列表的头部作为队列的尾部,使用列表的尾部作为队列的头部"的方案效果较好**
- **若所有被添加到队列中的元素最终都会被移除,则两个方案效果相同.**

方案1的实现:

```python
"""
Queue类 使用list头部表示queue头部 使用list尾部表示queue尾部
"""


class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        return self.items.insert(0, item)

    def dequeue(self):
        return self.items.pop()

    def is_empty(self):
        return self.items == []

    def size(self):
        return len(self.items)
```

方案2的实现:

```python
"""
Queue类 使用list头部表示queue尾部 使用list尾部表示queue尾部
"""


class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        return self.items.append(item)

    def dequeue(self):
        return self.items.pop(0)

    def is_empty(self):
        return self.items == []

    def size(self):
        return len(self.items)
```

### 3.4.4 模拟:传土豆

展示队列用法的一个典型方法就是模拟一个需要以FIFO方式管理数据的真实场景.考虑这样一个游戏:传土豆.

在这个游戏中,孩子们围成一圈,并以此尽可能快的传递一个土豆.在某个时刻,大家停止传递,此时手里有土豆的孩子就得退出游戏,重复上述过程,知道只剩下1个孩子.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%BC%A0%E5%9C%9F%E8%B1%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

这个游戏其实等价于著名的约瑟夫斯问题.弗拉维奥.约瑟夫斯是公园1世纪著名的历史学家.相传,约瑟夫斯当年和39个战友在山洞中对抗罗马军队.眼看着即将失败,他们决定自杀.于是他们围成一圈,从某人开始,按顺时针方向击杀第7人.约瑟夫斯同时也是一名数学家,据传说,他立刻找到了自己应该站的位置,从而是自己活到了最后.一说这个自杀活动最后只剩下他自己,他加入了罗马军队而非自杀;另一说这个自杀活动最后剩下他和另外一人,而他说服了另外一人,投降罗马军队;也有一说是每隔2人击杀一次;也有一说最后一人可以骑马逃跑.无论如何,问题是相似的.

#### a. 需求

请设计一个函数,该函数用于模拟传土豆游戏.该函数共2个参数.一个名字列表,另一个表示每次淘汰玩家时所需的传递次数(即传递多少次之后持有土豆者被淘汰).该函数返回一个字符串,该字符串表示本场游戏的胜利者.

- a. 名字列表中的第一个名字,即为游戏开始时持有土豆的玩家名字.
- b. 土豆传递的方向为:从名字列表中的第一个人,向后传递.
- c. 土豆结束一圈传递后,由第一个人开始继续向后传递,直到到达传递次数为止,此时持有土豆者被淘汰出局,继续下一轮淘汰.直到剩下1位玩家为止,游戏结束.该玩家为胜利者.

#### b. 实现思路

实际上这个需求描述的是一个环.在这个环中,先将土豆传递出去的玩家,就会先进入等待下一圈传递的序列中.而当一圈传递结束后,等待下一圈传递的序列和开始传递的序列是相同的.如下图示.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%BC%A0%E5%9C%9F%E8%B1%86%E6%B8%B8%E6%88%8F%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

直到传递次数到达指定次数,则此时手中有土豆的玩家被淘汰.继续开始下一轮淘汰.

若游戏序列长度不为1 且 本轮传递次数未到达指定次数 进入循环

循环中:

	每次取出(注意是取出不是获得)游戏序列中的第1个玩家 添加到等待游戏的序列中 表示该玩家从手中把土豆传递给别人了
	本轮传递次数+1
	若本轮传递次数到达指定次数 则游戏序列的第1个玩家被淘汰出局 
	本轮传递次数清0 等待序列中的玩家追加到游戏序列尾部 该游戏序列成为下一轮传递的其起始序列
	若游戏序列长度为0 则说明所有人均完成了一次传递而游戏未结束 此时等待序列成为了下一轮传递的起始序列
	
代码如下:

```python
from listHeadRepresentQueueHead import Queue


def pass_potato(players, pass_num):
    current_round_num = 0
    wait_queue = Queue()
    while True:
        while current_round_num < pass_num:
            if len(players) != 0:
                # 将送出土豆的玩家放入等待序列中
                wait_queue.enqueue(players.pop())
            else:
                # 将所有等待队列中的玩家放入游戏队列
                while not wait_queue.is_empty():
                    players.append(wait_queue.dequeue())
                # 游戏队列中的第1位玩家再次开始传递土豆
                wait_queue.enqueue(players.pop())
            current_round_num += 1

        while current_round_num == pass_num:
            # 到达传递次数 淘汰玩家
            if len(players) != 0:
                # 若此时游戏队列中还有玩家 则游戏队列中的第1位玩家被淘汰
                # 等待队列中的玩家被追加到游戏队列尾部
                eliminated = players.pop(0)
                while not wait_queue.is_empty():
                    players.append(wait_queue.dequeue())
            else:
                # 此时游戏队列中没有玩家 则等待队列中的第1位玩家被淘汰
                eliminated = wait_queue.dequeue()
                while not wait_queue.is_empty():
                    players.append(wait_queue.dequeue())

            print(eliminated)

            if len(players) == 1:
                return players
```

实际上这段代码实现的并不好.如上图所示:在未淘汰玩家时,一轮传递结束后,等待序列和游戏起始序列是完全相同的.所以上文代码的第一个缺点就出现了:

- 同样的数据,在游戏序列中则为list的一个元素,在等待序列中则为Queue的一个元素.

这是没有必要的.

这还不是致命的扣分点.真正致命的地方在于:是否有必要使用另外一个队列表示等待队列?实际上送出土豆的玩家进入等待队列,和站到游戏队列的队尾,这2个操作是<font color="red">**等效的.**</font>这个致命缺陷暴露出背后的问题在于:<font color="red">**写下这段代码时,并没有充分的理解和挖掘需求.**</font>所以才说<font color="red">**使用一个额外队列表示等待队列,是致命缺点.**</font>

<font color="red">**在编写算法方向的代码时,务必要注意的2个点在于:**</font>

- <font color="red">**将问题(需求)与算法分层**</font>
- <font color="red">**将算法与代码分层**</font>

改进后的处理流程图如下:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%BC%A0%E5%9C%9F%E8%B1%86%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE--%E6%94%B9%E8%89%AF%E7%89%88.jpg)

根据这个流程,我们的处理步骤应该为:

- step1. 将表示玩家姓名的list转化为Queue
- step2. 若本轮传递次数未到达指定次数,则将Queue头部元素移除,放入尾部,表示完成了一次传递
- step3. 记录本轮传递次数的计数器+1
- step4. 重复step2和step3,直到本轮传递次数到达指定次数
- step5. 将Queue头部元素移除,表示该玩家被淘汰了
- step6. 重复step2、step3、step4、step5,直到Queue的长度为1时,返回Queue中唯一的元素,该元素即为游戏获胜者

#### c. 实现

代码如下:

```python
def pass_potato(players, pass_num):
    current_round_num = 0
    players_queue = Queue()
    while len(players) != 0:
        players_queue.enqueue(players.pop(0))

    while players_queue.size() != 1:
        players_queue.enqueue(players_queue.dequeue())
        current_round_num += 1

        if current_round_num == pass_num:
            players_queue.dequeue()
            current_round_num = 0

    return players_queue.dequeue()
```

### 3.4.5 模拟:打印任务

再来看一个例子:

学生向共享打印机发送打印请求,这些打印任务被存储在一个<font color="red">**队列**</font>中,并且按照<font color="red">**先到先得**</font>的顺序执行.这样的设定可能会导致很多问题.其中最重要的问题在于:<font color="red">**打印机能否处理一定量的工作?**</font>若不能,则学生可能会因为等待时间过长,而错过自己要上的课.

考虑计算机科学实验室里的这样一个场景:在任何给定的<font color="red">**一小时**</font>内,实验室里都有约<font color="red">**10个**</font>学生.这10个学生每人在这1小时内<font color="red">**最多打印2次**</font>,且打印的页数从<font color="red">**1到20不等**</font>.实验室的打印机比较陈旧,<font color="red">**低质量打印速度为10页/分钟,高质量打印速度为5页/分钟.**</font>降低打印速度就有可能导致学生等待过长的时间.那么该如何设置打印速度呢?

可通过建模来解决该问题.我们需要为<font color="red">**学生、打印任务和打印机构建对象.**</font>如下图示.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%89%93%E5%8D%B0%E4%BB%BB%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

当学生提交打印任务时,我们需要将这些任务加入到等待列表中.该列表是打印机上的打印任务队列.当打印机执行完一个任务后,打印机将检查该队列,查看队列中是否还有待处理的任务.

我们感兴趣的是学生平均需要等待多久才能拿到打印好的文章.<font color="red">**这个时间等于所有打印任务在队列中的平均等待时间.**</font>

在模拟时,我们假设各页数出现的概率相等,则可以使用1~20的随机数来表示学生打印的页数.

设实验室内有10个学生,且在1小时内每个人都打印2次,则有:每小时平均20个任务.换算可得,每180秒1个任务.

	20个任务/小时 * 1小时/60分 * 1分/60秒 = 1个任务/180秒
	由 1个任务/180秒 可得, 每秒有任务创建的概率为 = 1/180
	
因此,我们同样可以使用随机数的方式来表示创建任务.使用随机数1~180来表示事件"创建任务"的发生.若随机数=180,则说明在这一秒有任务被创建,否则在这一秒没有任务被创建.

注意,可能会出现多个任务连接在短时间内连续被创建的情况(比如多次随机结果均为180),也有可能很长时间内都没有任务被创建(比如多次随机结果均不为180),这就是模拟的本质.

#### a. 主要模拟步骤

- a. 创建一个打印任务队列.每一个任务在进入队列时,都将获得一个时间戳,表示开始等待的时刻.初始时该队列为空.
- b. 针对每一秒,执行以下操作:

    - b1. 是否有新创建的打印任务?若有,则以当前时间的时间戳作为该任务开始等待的时刻并将该任务加入到队列中.
    - b2. 若打印机当前空闲,且当前存在等待执行的任务,则执行以下操作:

        - b2.1 从队列中取出第一个任务并提交给打印机
        - b2.2 使用当前时间的时间戳减去该任务的时间戳,得出该任务在队列中等待的时间
        - b2.3 将该任务的等待时间存入一个列表,后续备用
        - b2.4 根据该任务的页数,计算执行时间
    - b3. 打印机每进行1秒的打印,就需要从该任务所需的执行时间中减去1秒
    - b4. 若打印任务执行完毕,或任务需要的时间减少至0,则说明打印机处理任务完毕,回到空闲状态
- c. 当模拟完成后,根据等待时间列表中的值,计算平均等待时间.

#### b. Python实现

创建3个类:

- Printer类:模拟打印机
- Task类:模拟打印任务
- PrintQueue类:模拟打印队列

Print类需要检查当前是否存在正在执行中的任务.如果有,则打印机处于工作状态(busy()方法),且其所需时间可以根据任务要打印的页数来确定.其构造方法会初始化打印速度,速度单位为页数/分钟.tick()方法负责减量计时,且在任务执行完毕之后将打印机设置成空闲状态.

```python
class Printer:
    """
    构造方法:初始化打印机时需设定打印速度 打印速度的单位为: 页数/分钟
    初始化时Printer内部将设定无当前正在进行的任务 且 当前任务所需时间为0
    任务所需时间单位为:分钟
    """
    
    def __init__(self, pages_per_minute):
        self.print_speed = pages_per_minute
        self.current_task = None
        self.time_cost = 0

    """
    本方法负责以1秒/调用次数 的速度,减少当前任务所需时间
    若当前任务所需时间为0 则表示打印机中当前正在处理的任务结束了
    打印机又回到了等待执行任务的状态
    """
    
    def tick(self):
        if self.current_task is not None:
            self.time_cost -= 1
            if self.time_cost <= 0:
                self.current_task = None

    """
    本方法负责判断打印机当前的状态 若当前存在正在处理的任务 则打印机为繁忙状态
    否则 打印机为空闲状态
    """
    
    def is_busy(self):
        if self.current_task is not None:
            return True
        else:
            return False

    """
    本方法负责开始下一个任务 将下一个任务 以及下一个任务所需时间赋值到本类的
    current_task和time_cost字段上
    所需时间 = 任务打印页数 * 60 / 打印速度 其中 60为 分钟/小时 所需时间单位为:分钟
    """
    
    def start_next(self, new_task):
        self.current_task = new_task
        self.time_cost = new_task.get_pages() * 60 / self.print_speed
```

Task类表示单个打印任务.当任务被创建时,随机数生成器`random.randrange()`将为该任务设定要打印的页数.取值范围为1~20.同时每一个人物都需要保存一个时间戳,该时间戳表示任务被创建并放入打印队列的时间.wait_time()方法可以获得任务在队列中等待的时间.

```Python
import random


class Task:
    """
    构造方法:初始化任务时需设定任务被创建的时间戳
    初始化时Task内部将设置任务所要打印的页数
    """

    def __init__(self, timestamp):
        self.create_task_time = timestamp
        self.pages = random.randrange(1, 21)

    def get_create_task_time(self):
        return self.create_task_time

    def get_pages(self):
        return self.pages

    """
    本方法负责计算任务在队列中等待的时间 参数current_time的含义为任务从队列中出列
    进入打印机那一时刻的时间戳
    """

    def wait_time(self, current_time):
        return current_time - self.create_task_time
```

mock_lab_print()函数作为主程序,实现了上文描述的功能.tasks是Queue的一个实例.辅助函数is_new_task()判断是否有新的打印任务.计步器current_timestamp在不同的if代码块中有着不同的含义:

- 创建任务时,current_timestamp表示任务的创建时刻
- 执行任务时,current_timestamp表示任务的执行时刻

二者相减,实际上就是该任务在队列中等待的时刻

```python
from listHeadRepresentQueueTail import Queue
from Printer import Printer
from Task import Task
import random


def mock_lab_print(num_seconds, pages_per_minute):
    """
    :param num_seconds int 表示要模拟的时长 以秒为单位 例如 要模拟1小时 则该参数值为3600
    :param pages_per_minute int 表示打印机的速度 单位为页数/分钟
    """
    # 初始化打印机
    printer = Printer(pages_per_minute)

    # 初始化任务队列
    tasks = Queue()

    # 等待时间列表
    wait_times = []

    for current_timestamp in range(num_seconds):
        if is_new_task():
            # 创建任务 以当前的计步器值为任务的创建时刻
            task = Task(current_timestamp)
            tasks.enqueue(task)

        if (not printer.is_busy()) and (not tasks.is_empty()):
            # 取出下一个任务
            next_task = tasks.dequeue()
            # 以下一个任务进入打印机的时刻为任务开始被执行的时刻
            wait_times.append(next_task.wait_time(current_timestamp))
            # 打印机开始下一个任务
            printer.start_next(next_task)

        # 打印机开始工作
        printer.tick()

    average_wait_time = sum(wait_times) / len(wait_times)
    print("Average Wait %6.2f secs %3d tasks finished." % (average_wait_time, tasks.size()))


def is_new_task():
    probability = random.randrange(1, 181)
    if probability == 180:
        return True
    else:
        return False
```

## 3.5 双端队列

接下来学习另一个<font color="red">**线性数据结构.**</font>与栈和队列不同之处在于,双端队列的限制非常少.英文名deque([dɛk])

### 3.5.1 何谓双端队列

<font color="red">**双端队列:**</font>与队列类似,是一个有序集合.它有一前、一后两端,元素在其中保持自己的位置.与队列不同的地方在于,<font color="red">**双端队列对于在哪一端添加和移除元素没有任何的限制.**</font>新元素既可以被添加到前端,也可以被添加到后端.同样地,队列内的元素也可以从任何一端移除.某种意义上,双端队列是栈和队列的结合.

- 前端进入后端取出:即为队列
- 前端进入前端取出:即为栈

当然,后端进入前端取出以及后端进入后端取出,概念是相同的.

双端队列示意图:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

注意:<font color="red">**虽然双端队列有栈和队列的很多特性,但是双端队列本身并不要求使用者按照栈的LIFO原则或队列的FIFO原则来操作元素.**</font>具体的排序原则取决于使用者.

例如Redis的list数据类型,支持lpush/lpop/rpush/rpop操作.但并不要求使用lpush时必须使用lpop或rpop操作.

### 3.5.2 双端队列抽象数据类型

#### a. 双端队列的特性

- 1. 有序集合
- 2. 任何一端都允许添加或移除元素

#### b. 双端队列支持的操作

- 1. Deque():创建一个空的双端队列.该方法不需要参数,返回值为一个空的双端队列.
- 2. add_front(item):将一个元素添加到双端队列的前端.该方法接收一个item作为参数,没有返回值.
- 3. add_rear(item):将一个元素添加到双端队列的后端.该方法接收一个item作为参数,没有返回值.
- 4. remove_front():从双端队列的前端移除一个元素.该方法不需要参数,返回值为位于双端队列前端的元素,且会对双端队列造成修改.
- 5. remove_rear():从双端队列的后端移除一个元素.该方法不需要参数,返回值为位于双端队列后端的元素,且会对双端队列造成修改.
- 6. is_empty():检查双端队列是否为空.该方法不需要参数,返回值为一个布尔类型,True表示空双端队列,False表示非空双端队列.
- 7. size():检查一个双端队列中元素的数量.该方法不需要参数,且会返回一个整型.
		
`rear([rɪr] n. 后面；后方部队；屁股)`

#### c. 双端队列操作示例

双端队列操作 | 双端队列内容 | 返回值
:-: | :-: | :-:|
deque.is_empty() | [] | True
deque.add_rear(4) | [4] | 无
deque.add_rear('dog') | ['dog', 4] | 无
deque.add_front('cat') | ['dog', 4, 'cat'] | 无
deque.add_front(True) | ['dog', 4, 'cat', True] | 无
deque.size() | ['dog', 4, 'cat', True] | 4
deque.is_empty() | ['dog', 4, 'cat', True] | False
deque.add_rear(8.4) | [8.4, 'dog', 4, 'cat', True] | 无
deque.remove_rear() | ['dog', 4, 'cat', True] | 8.4
deque.remove_front() | ['dog', 4, 'cat'] | True

### 3.5.3 用Python实现双端队列

和队列以及栈类似,双端队列也是一个<font color="red">**有序集合.**</font>那么Python内置数据类型中,同样是有序集合的数据类型有:

- 列表
- 字符串
- 元组

很明显,字符串和元组都被pass了.

下一个问题还是要考量,如何实现更高效.无非还是上文中讲队列时提到的2个方案:

- 方案1:使用列表的头部作为双端队列的前端,使用列表的尾部作为双端队列的后端
- 方案2:使用列表的头部作为双端队列的后端,使用列表的尾部作为双端队列的前端

同样地,想要分析这2个方案那个更好,还是要分析两者的时间复杂度.

使用列表的头部作为双端队列的前端,使用列表的尾部作为双端队列的后端,则有:

- 从双端队列的前端添加元素,时间复杂度为O(n)
- 从双端队列的前端移除元素,时间复杂度为O(n)
- 从双端队列的后端添加元素,时间复杂度为O(1)
- 从双端队列的后端移除元素,时间复杂度为O(1)

使用列表的头部作为双端队列的后端,使用列表的尾部作为双端队列的前端,则有:

- 从双端队列的后端添加元素,时间复杂度为O(n)
- 从双端队列的后端移除元素,时间复杂度为O(n)
- 从双端队列的前端添加元素,时间复杂度为O(1)
- 从双端队列的前端移除元素,时间复杂度为O(1)

综上所述,对于双端队列来讲:

- <font color="red">**若前端的添加/移除操作较多,且后端的添加/移除操作较少,采用使用列表的头部作为双端队列的后端,使用列表的尾部作为双端队列的前端的实现方案较为合适**</font>
- <font color="red">**若后端的添加/移除操作较多,且前端的添加/移除操作较少,采用使用列表的头部作为双端队列的前端,使用列表的尾部作为双端队列的后端的实现方案较为合适**</font>

方案1的实现:

```python
"""
Deque类 使用list头部表示deque前端 使用list尾部表示deque后端
"""


class Deque:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def size(self):
        return len(self.items)

    def add_front(self, item):
        self.items.insert(0, item)

    def add_rear(self, item):
        self.items.append(item)

    def remove_front(self):
        return self.items.pop(0)

    def remove_rear(self):
        return self.items.pop()
```

方案2的实现:

```python
"""
Deque类 使用list头部表示deque后端 使用list尾部表示deque前端
"""


class Deque:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def size(self):
        return len(self.items)

    def add_front(self, item):
        self.items.append(item)

    def add_rear(self, item):
        self.items.insert(0, item)

    def remove_front(self):
        return self.items.pop()

    def remove_rear(self):
        return self.items.pop(0)
```

### 3.5.4 回文检测器

#### a. 需求

请设计一个函数,该函数用于检测一个字符串是否为<font color="red">**回文字符串.**</font>该函数接收1个参数.该参数为字符串类型.该函数有1个返回值,返回值为布尔类型.

- 回文字符串:从前往后读和从后往前读都一样的字符串.例如:

`
radar
toot
madam
...
`

#### b. 实现思路

##### b1. 使用字符作为核心数据结构实现该需求

- step1. 设字符串长度为`len_str`, 取 `len_str / 2`,若该结果不为整型,则向下取整,设该结果为`half_len`
- step2. 从0开始至`half_len`,遍历字符串,判断字符str[i]是否等于字符`str[len_str - 1 - i]`.
- step3. 若出现不相等的字符,则该字符串不是回文字符串.否则,该字符串为回文字符串.

实现见下文c1小节.可以看到,虽然函数的行数不多,但<font color="red">**可读性极差.**</font>整段代码充斥着一些具体数字.如果说`math.floor(len(pending_detection) / 2)`中的2还可以通过变量名`half_len`来解读,那么`len(pending)detection) - 1 - i`中的1和i则完全不可读,除非在已知该函数实现的功能为判断是否回文字符串的前提条件下,阅读该函数.否则很难明白这行代码中的减1和减i两个操作是何种意图.

为什么会出现这种情况呢?其最本质的原因在于:承载逻辑的数据结构选取不恰当.此处只能说是不恰当,并非不正确.因为我们使用字符作为核心数据结构,同样实现了这个需求.但我们使用字符,就需要花费大量的精力来处理细节.本例中我们处理的细节为:正确的找到字符串中,当前遍历的字符所对应的字符.

<font color="red">**因此,选取合适的数据结构去实现需求很重要.**</font>

##### b2. 使用双端队列作为核心数据结构实现该需求

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2--%E4%BD%BF%E7%94%A8%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

按上图所示,这个需求有如下2个特征:

- a. 集合是有序的

集合中的元素要求相对顺序和待检测字符串中的字符是一致的

- b. 从序列的左右两侧同时移除元素

移除后比对左右两侧移除的元素是否相同,即可得到回文字符串的检测结果.

因此,使用双端队列作为实现该需求的数据结构.

需要注意的一点是,把字符串转换为双端队列时,向双端队列中添加字符时,需要把<font color="red">**双端队列当做队列使用.**</font>即:对双端队列的添加操作,只能在单侧添加.否则将无法保证队列中元素的顺序与字符串中字符的顺序相一致.

添加操作如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2--%E5%90%91%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.jpg)

即:所有字符均应该在前端添加或均应该在后端添加.

#### c. 实现

##### c1. 使用字符作为核心数据结构的实现

```python
def is_palindrome_by_char(pending_detection):
    half_len = math.floor(len(pending_detection) / 2)
    for i in range(half_len):
        if pending_detection[i] != pending_detection[len(pending_detection) - 1 - i]:
            return False

    return True
```	

##### c2. 使用双端队列作为核心数据结构的实现

```python
def is_palindrome_by_deque(pending_detection):
    deque = Deque()

    # 将字符串中的字符在双端队列的队尾添加
    for char in pending_detection:
        deque.add_rear(char)

    # 从双端队列左右两侧同时取字符 比对是否相同
    while deque.size() > 1:
        # 原字符串中 左侧的字符在双端队列的前端 右侧的字符在双端队列的后端
        left_char, right_char = deque.remove_front(), deque.remove_rear()
        if left_char != right_char:
            return False

    return True
```

## 3.6 列表

之前实现栈、队列、双端队列这些ADT时,均使用了Python的内置数据类型list.list简洁而强大.它为程序员提供了很多的操作.但如果这门语言没有提供列表,就需要程序员手动实现列表.

列表:元素的集合.其中每个元素都有一个<font color="red">**相对于其他元素的位置(换言之,就是无绝对位置).**</font>这样的列表被称为<font color="red">**无序列表**</font>(因为没有排序规则.像栈、队列、双端队列,都是以元素的出入顺序作为排序规则).可以认为列表有第一个元素、第二个元素、第三个元素...也可以认为列表中的第一个元素为列表的起点,最后一个元素为列表的终点.此处我们假设53,26,93,17,77,31,93是一个考试分数的无序列表.

### 3.6.1 无序列表抽象数据类型

#### a. 无序列表的特性

- 1. 无序集合.其中每一个元素都有一个相对于其他元素的位置.

#### b. 无序列表支持的操作

- 1. List():创建一个空的列表.该方法不需要参数,且会返回一个空列表.
- 2. add(item):向列表头部添加元素.该方法接收一个item作为参数,无返回值.该方法会对列表造成修改.
- 3. remove(item):若item在列表中,则移除所有列表中所有值为item的元素.若item不在列表中,则触发异常.该方法接收一个item作为参数,无返回值,且会对列表造成修改.
- 4. search(item):在列表中搜索值为item的元素.该方法接收一个item作为参数,返回值为一个布尔类型.True表示item存在于列表中,False表示item不存在于列表中.
- 5. is_empty():检查列表是否为空.该方法不需要参数,返回值为一个布尔类型.True表示列表为空,False表示列表不为空.
- 6. length():返回列表中元素的个数.该方法不需要参数.返回值为一个整数.
- 7. append(item):在列表最后位置追加item.该方法接收一个元素作为参数,无返回值.该方法会对列表造成修改.
- 8. index(item):返回列表中值为item的元素在列表中的位置.若item在列表中不存在,则触发异常.
- 9. insert(pos, item):若pos为合理的值(即 0 <= pos <= 列表长度),则在列表中位置为pos处添加item.该方法接收2个参数,pos表示要添加元素在列表中的位置,item为要添加元素的值.
- 10. pop():若列表不为空,则移除列表中的最后一个元素.若列表为空,则触发异常.该方法不需要参数,返回值为一个元素.该方法会对列表造成修改.
- 11. pop(pos):若在指定位置pop存在元素,则移除该位置上的元素.若在指定位置pop上不存在元素,则触发异常.该方法接收一个pos作为参数,返回值为一个元素.该方法会对列表造成修改.

### 3.6.2 实现无序列表:链表

无序列表需要维持的是<font color="red">**元素之间的相对位置,**</font>而非在连续的内存空间中维护所有元素.如果可以为每一个元素维护一份<font color="red">**描述下一个元素位置的信息**</font>,那么这些元素的相对位置就能通过指向下一个元素的链接来表示.因此为了实现无序列表,应该构建<font color="red">**链表.**</font>如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E7%BB%B4%E6%8A%A4%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%BD%AE.jpg)

需要注意的点:

- a. 必须指明列表中第1个元素的位置.

		一旦知道第一个元素的位置,就能根据其中的链接信息访问第2个元素,进而能够根据第2个元素的链接信息访问第3个元素,以此类推.
- b. 最后一个元素需要知道自己没有下一个元素

指向链表第一个元素的引用被称为<font color="red">**头.**</font>

#### a. Node类

<font color="red">**节点(node)**</font>:构成链表的基本数据结构.每个节点对象都必须持有至少2份信息:

- a. 节点必须包含列表元素,称之为节点的<font color="red">**数据变量.**</font>
- b. 节点必须保存指向下一个节点的引用.
- c. 在创建一个节点时,需要为该节点提供初始数据变量.

特殊的Python引用值None在Node类以及之后的链表中起到了非常重要的作用.指向None的引用代表着后面没有元素.在我们的实现中,构造方法将下一个节点的引用设为None.这种做法有时被称为<font color="red">**将节点接地.**</font>因此我们使用接地符号来代表指向None的引用.如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E8%8A%82%E7%82%B9%E6%8E%A5%E5%9C%B0%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%8F%8A%E5%B8%B8%E8%A7%81%E8%A1%A8%E7%A4%BA%E6%B3%95.jpg)

代码如下:

```python
class Node:
    def __init__(self, init_data):
        self.data = init_data
        self.next = None

    def set_data(self, new_data):
        self.data = new_data

    def set_next(self, new_next):
        self.next = new_next

    def get_data(self):
        return self.data

    def get_next(self):
        return self.next
```

#### b. UnorderedList类

如上文所述,无序列表(unordered list)是基于节点集合来构建的.每一个节点都通过显式引用指向下一个节点.只要定位到第一个节点所在位置,其后的每一个元素都能通过下一个引用找到.因此,UnorderedList类必须包含指向第一个节点的引用.

那么,此时就存在一个问题:UnorderedList被实例化之后,尚未指向第一个节点时,应该是何种状态?

从逻辑上看,一个UnorderedList类的实例,在未指向第一个节点时,应该是一个空的UnorderedList.

从实现上看,可以参考Node类的实现.一个Node被初始化时,仅需节点的数据变量,即可完成初始化操作.换言之,并不需要设置这个Node指向何处,因为有可能这个Node就是整个LinkedList的最后一个Node.同理,一个UnorderedList,也有可能是一个空的UnorderedList.因此初始化UnorderedList时,应该是允许UnorderedList为空的.

UnorderedList类的构造方法实现如下:

```python
class UnorderedList:
    def __init__(self):
        self.head = None
```

其中,特殊引用值None用于表明头部没有指向任何节点.按照上文中的概念,实际上这里就是<font color="red">**将列表头部接地.**</font>如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E7%A9%BA%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

最终,上文中给出的样例列表如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%A0%B7%E4%BE%8B%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

所以,用于判断UnorderedList是否为空的is_empty()方法,其应该检查的内容为:<font color="red">**检查列表的头部是否为指向None的引用.**</font>

UnorderedList类的is_empty()方法实现如下:

```python
def is_empty(self):
    return self.head is None
```

<font color="red">****</font>