# 第3章 基本数据结构

## 3.1 本章目标

- 理解栈、队列、双端队列、列表等抽象数据类型
- 能够使用Python列表实现栈、队列和双端队列
- 理解基础线性数据结构的性能
- 理解前序、中序和后序表达式
- 使用栈来计算后序表达式
- 使用栈将中序表达式转换成后序表达式
- 使用队列进行基本的时序模拟
- 理解栈、队列以及双端队列适用于解决何种问题
- 能够使用"节点与引用"模式将列表实现为列表
- 能够从性能方面比较自己的链表实现与Python的列表实现

## 3.2 何谓线性数据结构

栈、队列、双端队列和列表都是<font color="red">**有序的**</font>数据集合.<font color="red">**其元素的顺序取决于添加顺序或移除顺序.**</font>

<font color="red">**线性数据结构:一旦某个元素被添加进来,它与前后元素的相对位置将保持不变.**</font>

线性数据结构可以看做有<font color="red">**两端.**</font>真正区分某个数据结构是否为线性数据结构的是:<font color="red">**元素的添加方式和移除方式,特别是添加操作和移除操作发生的位置.**</font>例如,某个数据结构可能只允许在一端添加新元素,有些则允许从任意一端移除元素.

## 3.3 栈

### 3.3.1 何谓栈

<font color="red">**栈:**</font>栈是<font color="red">**有序集合,且添加操作和移除操作总发生在同一端,**</font>即"顶端",另一端则被称为"底端".

		注:此处的集合不是数学上集合的概念.因为数学定义的集合,是不允许重复元素出现的.

<font color="red">**栈中的元素离底端越近,表示该元素在栈中存在的时间越长.**</font>因此栈的底端有非常重要的含义.

栈的排序原则:<font color="red">**后入先出.即新添加的元素将被最先移除.这种排序原则被称为LIFO(Last-In First-Out).**</font>

栈提出了一种<font color="red">**基于元素存在于集合中的时间来排序的方式.**</font>元素存在于集合中的时间越长,则越靠近底端;反之则靠近顶端.

举一个日常生活中的例子:

我经常买很多书然后又不看,这些书就叠成了一摞.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B9%A6%E6%9E%84%E6%88%90%E7%9A%84%E6%A0%88.jpg)

在这一摞书中,唯一露出封面的书就是顶部的那本.为了拿到其他的某本书,需要移除压在这本书上面的所有书.

观察这一摞书是如何一本一本的码起来的,就能理解栈的重要思想.假设桌面一开始是空的,每次只能往桌上放一本书.如此堆叠,就构建出了一个栈.

而取书的顺序与放书的顺序正好相反:想要取到某本书,则必须先从这一摞书的顶部开始,一次一本的拿走,直到取到自己想拿的那本书为止.而这个过程,也就是拆除了一个栈的过程.

再进一步思考:如果从这一摞书中,自上而下一次一本的拿走,将这些拿走的书再放成另一摞,则构成了另一个栈,且新栈与原栈恰好是逆序的关系.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%A0%88%E7%9A%84%E5%8F%8D%E8%BD%AC--%E4%BB%A5%E4%B9%A6%E4%B8%BA%E4%BE%8B.jpg)

再来看由原生Python数据对象构成的栈:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E7%94%B1%E5%8E%9F%E7%94%9FPython%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E6%9E%84%E6%88%90%E7%9A%84%E6%A0%88.jpg)

那么根据刚刚拿书的例子,我们来看一看<font color="red">**栈的反转特性:**</font>

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%A0%88%E7%9A%84%E5%8F%8D%E8%BD%AC%E7%89%B9%E6%80%A7.jpg)

根据这个特性,可以想到一些在使用计算机时的例子.比如我们在浏览网页时,这些网页的URL就被存放在了一个栈中.当前打开的网页位于栈的最顶端,最早打开的网页位于栈的最低端.点击后退按钮,则开始反向浏览这些网页.

### 3.3.2 栈抽象数据类型

#### a. 栈的特性

- 1. 有序集合
- 2. 添加与移除操作都发生在顶端
- 3. 操作顺序为LIFO

#### b. 栈支持的操作

根据栈的特性,如果我们要自己设计一个栈,应该支持如下的操作;

- 1. Stack():创建一个空栈.该方法不需要参数,返回值为一个空栈.
- 2. push(item):将一个元素添加到栈的顶端.该方法接收一个参数item,无返回值.
- 3. pop():将栈顶端的元素移除.该方法不需要参数,返回值为顶端的元素,且会对栈造成修改.
- 4. peek():查看栈顶端的元素.但并不移除该元素.该方法不需要参数,无返回值,不会对栈造成修改.
- 5. is_empty():检查栈是否为空.该方法不需要参数,返回值为一个布尔类型,True表示空栈,False表示非空栈.
- 6. size():检查一个栈中元素的数量.该方法不需要参数,且会返回一个整型.

#### c. 栈操作示例

<table border="1px solid black">
    <thead>
    <tr>
        <td>栈操作</td>
        <td>栈内容</td>
        <td>返回值</td>
    </tr>
    </thead>
    <tr>
        <td>stack.isEmpty()</td>
        <td>[]</td>
        <td>True</td>
    </tr>
    <tr>
        <td>stack.push(4)</td>
        <td>[4]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.push('dog')</td>
        <td>[4, 'dog']</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.peek()</td>
        <td>[4, 'dog']</td>
        <td>'dog'</td>
    </tr>
    <tr>
        <td>stack.push(True)</td>
        <td>[4, 'dog', True]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.size()</td>
        <td>[4, 'dog', True]</td>
        <td>3</td>
    </tr>
    <tr>
        <td>stack.is_empty()</td>
        <td>[4, 'dog', True]</td>
        <td>False</td>
    </tr>
    <tr>
        <td>stack.push(8.4)</td>
        <td>[4, 'dog', True, 8.4]</td>
        <td>无</td>
    </tr>
    <tr>
        <td>stack.pop()</td>
        <td>[4, 'dog', True]</td>
        <td>8.4</td>
    </tr>
    <tr>
        <td>stack.pop()</td>
        <td>[4, 'dog']</td>
        <td>True</td>
    </tr>
    <tr>
        <td>stack.size()</td>
        <td>[4, 'dog']</td>
        <td>2</td>
    </tr>
</table>

### 3.3.3 用Python实现栈

栈是一个有序集合,那么Python中同样是有序集合的数据类型有:

- 列表
- 字符串
- 元组

从这三者中,很明显应该使用列表数据类型来实现栈.在实现时,只需要考虑将列表中的哪一端视为顶端即可.一旦确定了顶端,所有针对栈的操作均可使用list的相关操作来实现.

#### 实现方式A:用list的尾部表示stack的顶部

- a. 该方式的优点:使用list.append()和list.pop()即可实现元素的入栈和出栈.这2个操作的时间复杂度均为O(1).性能好.
- b. 该方式的缺点:不直观.list的排列顺序和stack的顺序相反.

代码如下:

```python
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        if not self.items:
            return True
        else:
            return False

    def push(self, item):
        self.items.append(item)
        return

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            return IndexError("IndexError: pop from empty stack")

    def size(self):
        return len(self.items)

    def peek(self):
        if not self.is_empty():
            return self.items[self.size() - 1]
        else:
            return IndexError("IndexError: stack index out of range")

```

#### 实现方式B:用list的头部表示stack的顶部

- a. 该方式的优点:直观.由于list的头部表示stack的顶部,list的排列顺序和stack的顺序一致.
- b. 该方式的缺点:性能差.使用list的头部表示stack的顶部,则元素入栈需使用`list.insert(0, item)`操作,元素出栈需使用`list.pop(0)`操作,这2个操作的时间复杂度均为O(n).

代码如下:

```python
class Stack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        if not self.items:
            return True
        else:
            return False

    def push(self, item):
        self.items.insert(0, item)
        return

    def pop(self):
        if not self.is_empty():
            return self.items.pop(0)
        else:
            return IndexError("IndexError: pop from empty stack")

    def peek(self):
        if not self.is_empty():
            return self.items[0]
        else:
            return IndexError("IndexError: stack index out of range")

    def size(self):
        return len(self.items)

```

### 3.3.4 匹配括号

#### a. 需求

匹配括号:每一个左括号都有与之对应的一个右括号,且括号对有正确的嵌套关系.

例如:

- (()()()())
- ((()))
- (()((()())))

均为正确匹配的括号串.

例如:

- (((((())
- ()))
- (()()()

则不是正确匹配的括号串.

请编写一个算法,该函数从左到右读取一个括号串,并判断其中的括号是否匹配.

#### b. 实现思路

如果仅仅是匹配一个字符串内的'('和')'的个数是否相同,是很好实现的.但是,这个需求要求的是<font color="red">**不仅'('和')'的个数相同,且括号对有正确的嵌套关系.**</font>那么就有可能出现下图中的情况:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%8C%B9%E9%85%8D%E6%8B%AC%E5%8F%B7.jpg)

对于一个<font color="red">**未匹配到')'的'('**</font>而言:

- 若这个'('是整个字符串中的<font color="red">**最后一个**</font>未匹配到')'的'(',则与之匹配的')'必然和之后遇到的第一个')'匹配;
- 若这个'('是整个字符串中<font color="red">**第一个**</font>未匹配到')'的'(',则有可能要等到处理至最后一个位置的')',才能被认为是完成匹配;

匹配的规律,实际上就是一个元素出栈入栈的规律.

- 创建一个空栈,从左到右依次处理括号(即遍历字符串获取每个字符)
- 若当前字符为'(',则压入栈中,表示稍后<font color="red">**可能**</font>会有一个')'与之匹配
- 若当前字符为')',则弹出栈顶的<font color="red">**1个**</font>元素,表示找到了与弹出栈的'('相匹配的')'
- 遍历完毕后若栈仍为空栈,则说明该字符串中的括号是匹配的.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def par_checker(par_string):
    checked_stack = Stack()
    is_balanced = True
    for i in range(0, len(par_string), 1):
        checked_char = par_string[i]
        if checked_char == '(':
            checked_stack.push(checked_char)
        elif checked_char == ')':
            checked_stack.pop()

    if checked_stack.is_empty():
        return is_balanced
    else:
        print(checked_stack.items)
        is_balanced = False
        return is_balanced


print(par_checker("(()()()())"))

```

### 3.3.5 匹配符号

#### a. 需求

匹配符号:每一个左符号都有与之对应的一个右符号,且成对出现的符号有正确的嵌套关系.

例如:

- {{[][]}()}
- [[{{(())}}]]
- [][]\[](){}

均为正确匹配的符号串.

例如:

- ([)]
- ((()]))
- [{()]

则不是正确匹配的符号串.

#### b. 实现思路

基于3.3.4的实现思路,仅需要小小的改动即可:

- a. 遍历待检测字符串
- b. 遇到左符号,入栈
- c. 遇到右符号,出栈
- d. 出栈后比对左符号和右符号是否匹配.(即:当前检测的字符为']',出栈的元素是否为'[')
- e. 若出栈的字符和当前检测的字符匹配,则继续比对下一个字符
- f. 否则,待检测字符串不匹配.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def symbol_checker(par_string):
    checked_stack = Stack()

    is_balanced = True

    for i in range(0, len(par_string), 1):
        checked_char = par_string[i]
        if checked_char in "([{":
            checked_stack.push(checked_char)
        elif checked_char in ")]}":
            right_symbol = checked_stack.pop()
            if is_matches(right_symbol, checked_char):
                continue
            else:
                is_balanced = False
                return is_balanced

    return is_balanced


def is_matches(left_symbol, right_symbol):
    left_chars = "([{"
    right_chars = ")]}"
    return left_chars.index(left_symbol) == right_chars.index(right_symbol)
```

### 3.3.6 十进制数转二进制数

#### a. 需求

请设计一个函数,该函数接收一个十进制的自然数,返回该整数的二进制表示.

#### b. 实现思路

我们找一个十进制正整数,看看它如何转换为二进制数.

以十进制数233为例:

233 = 2 * 10^2 + 3 * 10^1 + 3 * 10^0

233 = 1 * 2^7 + 1* 2^6 + 1 * 2^5 + 0 * 2^4 + 1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0

因此:233的二进制表示为:11101001

如何得出的二进制表示法呢?

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.jpg)

如上图示,使用"除以2"算法.

- a. 该算法是一个简单的循环,不停地将十进制数除以2,并记录余数,直到十进制数小于2(也就是图中的"商为0")为止.
- b. 将每一次除法得出的余数倒序排列,即为该十进制数的二进制表示.

为什么这个算法是这个操作呢?

我们来想一想第一次除法:

- a. 第一次除法得出的余数为0,则该十进制数为偶数,进而可知:该十进制数的二进制表示中,最后一位应该为0
- b. 第一次除法得出的余数为1,则该十进制数为奇数,进而可知:该十进制数的二进制表示中,最后一位应该为1
- c. 第二次除法得出的余数为0,则该十进制数 % 4 为0,进而可知:该十进制数的二进制表示中,倒数第二位应该为0
- d. 第二次除法得出的余数为1,则该十进制数 % 4 为1,进而可知:该十进制数的二进制表示中,倒数第二位应该为1

...

以此类推,当商为0时,即可得出该十进制数的二进制表示中的第1位的值.

#### c. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack
import math


def convert_decimal_to_binary(decimal):
    division_flag = True
    binary_stack = Stack()
    last_decimal = decimal

    while division_flag:
        quotient = math.floor(last_decimal / 2)
        remainder = last_decimal % 2
        binary_stack.push(remainder)
        last_decimal = quotient
        # 当商 < 进制数 时 不再做除法操作
        if quotient == 0:
            division_flag = False

    binary_str = ""
    for i in range(0, binary_stack.size(), 1):
        binary_str += str(binary_stack.pop())

    return binary_str
```

更精简的代码实现:

```python
def divide_by_2(dec_number):
    rem_stack = Stack()

    while dec_number > 0:
        rem = dec_number % 2
        rem_stack.push(rem)
        # // 在python中表示取整除
        dec_number = dec_number // 2

    bin_str = ""
    while not rem_stack.is_empty():
        bin_str += str(rem_stack.pop())

    return bin_str
```

#### d. 更通用的需求

##### d1. 需求

在计算机科学中,常常还要使用到八进制、十六进制的数字.那么上面的实现就满足不了这种更通用的需求了.因此,此时我们的需求是:

- 请设计一个函数,该函数接收一个十进制的自然数和一个标识进制的数字(假定进制不超过16),返回该自然数的指定进制的表示.

##### d2. 实现思路

我们之前的实现,有2点不满足该需求:

- a. 无法指定进制
- b. 当指定的进制超过10时,不知道该用什么字符表示

无法指定进制的问题相对比较好解决,将函数中的常数换成变量即可.但指定的进制超过10之后无法表示,这个问题就不好解决了.我们可以效仿十六进制的表达方式,<font color="red">**添加一些字母到数字中去**</font>.

在十六进制中:

- a表示10
- b表示11
- c表示12
- ...
- f表示15

#### d3. 实现

代码如下:

```python
from listTailToRepresentStackTop import Stack


def convert_decimal_to_any_scale(decimal, scale_num):
    scale_stack = Stack()
    num_chars = "0123456789ABCDEF"

    while decimal > 0:
        remainder = decimal % scale_num
        scale_stack.push(remainder)
        decimal = decimal // scale_num

    scale_str = ""

    while not scale_stack.is_empty():
        scale_str += num_chars[scale_stack.pop()]

    return scale_str
```

### 3.3.7 前序、中序和后序表达式

#### a. 简介

<font color="red">**中序表达式:**</font>运算符出现在2个操作数<font color="red">**中间**</font>的表达式,被称为中序表达式.

例如:像`B * C`这样的算术表达式,可以根据其结构来进行正确的运算.在`B * C`中,由于乘号`*`出现在两个变量之间,因此我们知道应该用变量B乘以变量C.

再来看另外一个中序表达式的例子:`A + B * C`,虽然运算符`+`和运算符`*`都在操作数之间,但是有几个问题:

- 这两个符号分别用于哪些操作数?
- `+`是否作用于A和B?
- `*`是否作用于B和C?

这个表达式看起来是有歧义的.

实际上我们经常读写这类表达式,并没有遇到任何问题.这是因为我们知道`+`和`*`的特点.每一个运算符都有一个<font color="red">**优先级.**</font><font color="red">**在运算时,高优先级的运算符先于低优先级的运算符.唯一能够改变运算顺序的就是括号.若两个运算符的优先级相同,则按照从左到右或者结合律的顺序进行运算.**</font>

从运算符优先级的角度来理解`A = B * C`:

- step1. 计算 `B * C`
- step2. 计算 `A + 乘积`

从运算符优先级的角度来理解`(A + B) * C`:

- step1. 计算`A + B`
- step2. 计算`和 * C`

从运算符优先级的角度来理解`A + B + C`:

- step1. 计算`A + B`
- step2. 计算`和 + C`

那么问题来了:这种规律对于人来讲,显而易见,但是计算机来处理这个问题,就必须定义明确规则了.一种杜绝歧义的写法是<font color="red">**完全括号表达式.这种表达式对每一个运算符都添加一对括号,由括号来决定运算的顺序,没有任何歧义,且不需要定义任何的优先级规则.**</font>

例如:`A + B * C + D`可以被重写成`((A + (B * C)) + D)`,用以表明:

- step1. 计算`B * C`
- step2. 计算`A + 乘积`
- step3. 计算`和 + D`

例如:`A + B + C + D`可以被重写成`(((A + B) + C) + D)`,用以表明:

- step1. 计算`A + B`
- step2. 计算`和 + C`
- step3. 计算`和 + D`

还有另外2种重要的表达式,可能不太能够做到一目了然地看出它们的含义:

<font color="red">**前序表达式:**</font>运算符出现在2个操作数<font color="red">**之前**</font>的表达式,被称为前序表达式.

例如:`+ A B`

实际上这种表达式也被应用于编程语言中,如LISP:

```LISP
(defun square(n)
	(* n n))
```

这段代码定义了一个名为square的函数.该函数会返回参数n的平方.

<font color="red">**后序表达式:**</font>运算符出现在2个操作数<font color="red">**后边**</font>的表达式,被称为后序表达式.

例如:`A B +`

中序、前序与后序表达式:

<table border="1px solid black">
    <thead>
    <tr>
        <td colspan="3">中序、前序与后序表达式</td>
    </tr>
    </thead>
    <tr>
        <td>中序表达式</td>
        <td>前序表达式</td>
        <td>后序表达式</td>
    </tr>
    <tr>
        <td>A + B</td>
        <td>+ A B</td>
        <td>A B +</td>
    </tr>
    <tr>
        <td>A + B * C</td>
        <td>+ A * B C</td>
        <td>A B C * +</td>
    </tr>
</table>

前序表达式和后序表达式通过运算符的优先级来确保正确的运算顺序.例如:

- `A + B * C`转换为前序表达式为`+ A * B C`,`*`出现在B和C之前,表示`*`的优先级高于`+`.进而`+`出现在A和乘法结果之前.
- `A + B * C`转换为后序表达式为`A B C * +`.`*`出现在B和C之后,表示`*`的优先级高于`+`.进而`+`出现在A和乘法结果之后.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B8%AD%E5%BA%8F%E3%80%81%E5%89%8D%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

那么,对于带有括号的中序表达式,例如`(A + B) * C`,它的中序、前序与后续表达式该怎么写?

<table border="1px solid black">
    <thead>
    <tr>
        <td colspan="3">中序、前序与后序表达式</td>
    </tr>
    </thead>
    <tr>
        <td>中序表达式</td>
        <td>前序表达式</td>
        <td>后序表达式</td>
    </tr>
    <tr>
        <td>(A + B) * C</td>
        <td>* + A B C</td>
        <td>A B + C *</td>
    </tr>
</table>

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E6%94%B9%E5%8F%98%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E4%B8%AD%E5%BA%8F%E3%80%81%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

注意:`(A + B) * C`的后序表达式只能是`A B + C *`,不能是`C A B + *`,二者虽然计算后的值是相同的,但后者表示的中序表达式是`C * (A + B)`

中序、前序与后序表达式示例

<table border="1px solid black">
    <thead>
    <tr>
        <td colspan="3">中序、前序与后序表达式示例</td>
    </tr>
    </thead>
    <tr>
        <td>中序表达式</td>
        <td>前序表达式</td>
        <td>后序表达式</td>
    </tr>
    <tr>
        <td>A + B * C + D</td>
        <td>+ + A * B C D</td>
        <td>A B C * + D +</td>
    </tr>
    <tr>
        <td>(A + B) * (C + D)</td>
        <td>* + A B + C D</td>
        <td>A B + C D + *</td>
    </tr>
    <tr>
        <td>A * B + C * D</td>
        <td>+ * A B * C D</td>
        <td>A B * C D * +</td>
    </tr>
    <tr>
        <td>A + B + C + D</td>
        <td>+ + + A B C D</td>
        <td>A B + C + D +</td>
    </tr>
</table>

#### b. 从中序向前序和后序转换

存在通用的算法,可用于正确转换任意复杂度的表达式.

首先使用完全括号表达式.上文中说过,可以将`A + B * C`写作`(A + (B * C))`,以便表示`*`的优先级高于`+`.<font color="red">**在完全括号表达式中,每对括号都对应着一个中序表达式(包含2个操作数以及这2个操作数中间的运算符).**</font>

对于一个中序表达式,无论其多么的复杂,均可按照如下步骤,转化为一个后序表达式:

- step1. 将`*`挪动到`)`的位置上
- step2. 将`)`对应的`(`删除
- step3. 将`+`挪动到`)`的位置上
- step4. 将对应的`(`删除

即可得到一个中序表达式对应的后序表达式.

具体转换过程如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

同样的,对于一个中序表达式,按照如下步骤,即可转化为一个前序表达式:

- step1. 将`*`挪动到`(`的位置上
- step2. 将对应的`)`删除
- step3. 将`+`挪动到`(`的位置上
- step4. 将对应的`)`删除

具体转换过程如下图示:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%89%8D%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

一个复杂一点的例子:(A + B) * C - (D - E) * (F + G)

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%89%8D%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

最终结果如下:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%A4%8D%E6%9D%82%E7%9A%84%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E5%89%8D%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F.jpg)

#### c. 从中序到后序的通用转换法

##### c1. 需求

需求:<font color="red">**请设计一个函数,该函数可以将任意中序表达式转换为后序表达式.**</font>

- a. 该函数接收一个以<font color="red">**字符串形式**</font>表示的中序表达式.
- b. 该字符串以空格为分隔符
- c. 该中序表达式中仅含有`+ - * /`四种操作符
- d. 该中序表达式中可能含有`()`
- e. 该函数的返回值为该中序表达式的后序表达式

##### c2. 不带括号的中序表达式改写为后序表达式的过程

我们再来看`A + B * C`的例子.其后序表达式为`A B C * +`.我们发现无论是将一个中序表达式转换为前序还是后序表达式,转换后的表达式,操作数的相对位置均不发生改变.改变的只有操作符的位置.再来看中序表达式中运算符的位置与计算顺序:

- 位置:从左往右看,先出现`+`再出现`*`
- 计算顺序:先计算`*`再计算`+`

我们发现操作符的计算顺序和后序表达式中操作符的出现顺序是一样的,但和中序表达式中操作符的出现顺序是<font color="red">**相反**</font>的.

在转换的过程中,因为运算符右边的操作数还没有出现,因而需要将运算符保存在某处.例如:`A + B`

-  1. 看到A
-  2. 看到`+`,保存起来,继续看下一个字符
-  3. 看到B
-  4. 此时,`A + B`才是<font color="red">**可计算的**</font>

这才是我们需要暂时将运算符保存起来的原因.

进而看一个更复杂的例子:`A + B * C`

- 1. 看到A
- 2. 看到`+`保存起来,继续看下一个字符
- 3. 看到B

但是,此时并不能计算`A + B`,因为右边有一个运算优先级高于`+`的操作符`*`

- 4. 看到`*`保存起来,继续看下一个字符
- 5. 看到`C`
- 6. 此时,`B * C`成为一个<font color="red">**可计算的表达式**</font>
- 7. 进而,`A + B * C`成为一个<font color="red">**可计算的表达式**</font>

至此,我们可以得出结论:<font color="red">**只有当一个优先级较高的运算符完成计算后,其左侧的优先级较低的运算符才可计算.**</font>

##### c3. 带有括号的中序表达式改写为后序表达式的过程

对于`(A + B) * C`,其后序表达式为`A B + C *`.同样地,操作数的相对位置没有发生改变.但由于`()`的出现,改变了操作符的运算优先级,使得在后序表达式中,`+`出现在了`*`前面.按照从左向右看的顺序,我们来分析这个表达式的计算过程:

- 1. 看到`(`,保存起来,继续看下一个字符
- 2. 看到A
- 3. 看到`+`,保存起来,继续看下一个字符
- 4. 看到B
- 5. 看到`)`

此时,这个`)`的出现,就是一种标识:标识着2件事:

    - a. 即将出现一个操作符,该操作符的运算优先级高于括号内的操作符
    - b. `()`内的表达式需要计算

因此,后续步骤为:

- 6. 计算`()`内的表达式(本例中即为`A + B`)
- 7. 看到`*`,保存起来,继续看下一个字符
- 8. 看到`C`
- 9. 此时,`(A + B) * C`成为了一个<font color="red">**可计算的表达式**</font>

##### c4. 实现思路

###### 问题1:使用何种数据结构来处理该需求最为合适?

根据c2和c3两个部分的思考,我们整理出了3个点:

- a. 转换的过程中需要<font color="red">**将运算符暂时保存起来,当该运算符可计算时,再取出该运算符并计算.**</font>

- b. 同时,由于运算符优先级的影响,还有可能存在<font color="red">**后出现的运算符先运算,即:运算顺序与出现顺序相反**</font>的情况.
- c. <font color="red">**`()`的出现会改变操作符的计算优先级.**</font>

在这3个点中,我们发现关键字是<font color="red">**暂存**</font>和<font color="red">**顺序相反**</font>.这2个关键字是<font color="red">**栈的特性.**</font>因此,<font color="red">**这个需求应该使用栈来暂存操作符和`()`**</font>

###### 问题2:具体步骤该怎么做?

根据上边的几个例子,我们可以总结出算法的大致步骤:

- step1. 遍历字符串,取其中的每一个字符
- step2. 分类讨论:
	
	若该字符为<font color="red">**操作数,**</font>则追加到结果列表尾部.继续遍历下一个字符;
	
	若该字符为<font color="red">**操作符,**</font>则继续分类讨论:
		
		若此时栈为空,则直接将该操作符压入栈内,继续遍历下一个字符
		若此时栈不为空,则:
			若栈顶操作符的运算优先级低于当前操作符,则直接将该操作符压入栈内,继续遍历下一个字符
			若栈顶操作符的运算优先级高于或等于当前操作符,则:
				①. 从栈内弹出元素,直到栈顶操作符的运算优先级低于当前操作符
				②. 把当前操作符压入栈内
						
	若该字符为<font color="red">**`(`**</font>,则压入栈中,继续遍历下一个字符;
	
	若该字符为<font color="red">**`)`**</font>,则从栈内弹出元素,直到弹出的值为`(`为止,并将弹出的所有元素(除`(`外)追加到结果列表中,然后遍历下一个字符;
	
		需要注意的是:按上述规则,对于一个)而言,与其匹配的(一定为最先从栈中弹出的那个(.实际上这也是顺序相反的一种体现.
		
	若遍历到了字符串结尾,则将栈中所有的操作符一一弹出,并按弹出顺序追加至结果列表尾部.
	
以`A * B + C * D`为例,演示上述过程:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%B8%AD%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%BC%94%E7%A4%BA.jpg)

###### 问题3:如何表示运算符的优先级?

可以使用一个字典,该字典将每个运算符映射为一个整数,以该整数的大小表示运算符优先级的高低.<font color="red">**其中`(`的优先级最低,可以把它理解为一个调整操作符优先级的标志.**</font>

##### c5. 实现

```python
import string
from listTailToRepresentStackTop import Stack


def convert_infix_to_epilogue(infix):
    infix = infix.split()

    # 优先级字典
    priority = {
        "*": 3,
        "/": 3,
        "+": 2,
        "-": 2,
        "(": 1
    }

    # 暂存操作符的栈
    operators = Stack()

    # 后序表达式字符列表
    epilogue = []

    for char in infix:
        if char in string.ascii_uppercase:
            # 操作数直接追加至后续表达式列表结尾
            epilogue.append(char)
        else:
            if char == '(':
                # ( 直接压入栈内
                operators.push(char)
            elif char == ')':
                # ) 从栈内弹出元素 直到弹出的元素为(为止 并将这些弹出的操作符追加到结果列表中
                operator = operators.pop()
                while operator != '(':
                    epilogue.append(operator)
                    operator = operators.pop()
            elif operators.is_empty():
                # 栈为空 则将当前运算符直接压入栈内
                operators.push(char)
            else:
                if priority[operators.peek()] < priority[char]:
                    # 栈不为空 且栈顶操作符的优先级低于当前操作符 直接将当前操作符压入栈内
                    operators.push(char)
                else:
                    # 栈不为空 且栈顶操作符的优先级高于或等于当前运算符
                    # 先将栈内所有运算优先级高于或等于当前运算符的运算符弹出 追加到结果列表尾部
                    # 再将当前运算符压入栈内
                    if priority[operators.peek()] >= priority[char]:
                        epilogue.append(operators.pop())
                    else:
                        operators.push(char)

    # 遍历结束 如栈内还有操作符 则弹出并追加到结果列表尾部
    # 因为遍历已经结束了 所以必然在栈内不会有( 因此不用判断
    while not operators.is_empty():
        # print(operators.items)
        epilogue.append(operators.pop())

    return " ".join(epilogue)
```

#### d. 从后序到中序的通用转换法

##### d1. 需求

请设计一个函数,<font color="red">**该函数接收一个后序表达式,该函数可以计算一个后序表达式的值.**</font>

- a. 该函数接收一个以<font color="red">**字符串形式**</font>表达的后序表达式
- b. 该字符串以<font color="red">**空格**</font>为分隔符
- c. 该后序表达式中仅含有`+ - * /`四种操作符
- d. 该后序表达式中的操作数全部为<font color="red">**自然数**</font>
- e. 该函数的返回值为该后续表达式计算后的值

##### d2. 实现思路

###### 问题1:以一个例子分析问题

以后序表达式`4 5 6 * +`为例.还是从左向右看,则有如下步骤:

- step1. 看到<font color="red">**操作数`4`**</font>,因为此时不知道要对该操作数做何种操作(即不知道操作符),所以先暂存在某个地方,等需要用时再取.
- step2. 看到<font color="red">**操作数`5`**</font>,暂存.理由同上
- step3. 看到<font color="red">**操作数`6`**</font>,暂存.理由同上
- step4. 看到<font color="red">**操作数`*`**</font>,则此时<font color="red">**从`*`的位置从右向左找,**</font>找到<font color="red">**距离`*`最近的2个操作数**</font>,实际上这2个数就是最后2次暂存的操作数.
- step5. 则此时一个最基本的表达式就构成了,计算该表达式的值,并用这个值替换原后序表达式中的操作数和操作符的位置.

		例:在本例中,即为 5 6 *.一个表达式构成了,就意味着该表达式从不可计算的状态转化为可计算的状态了.
		① 5 6 * 使用中序表达式来表达的话就是:5 * 6,该表达式的值为30
		② 用30替换原表达式中5 6 * 这3个字符的位置
		③ 此时替换后的表达式为 4 30 +

- step6. 看到<font color="red">**`+`**</font>,则此时<font color="red">**从`+`的位置从右向左找,**</font>找到<font color="red">**距离`*`最近的2个操作数**</font>
- step7. 此时又构成了一个最基本的表达式,计算该表达式的值.由于遍历已经结束,因此该值即为最终结果.

###### 问题2:实现步骤

- step1. 创建空栈
- step2. 将后序表达式转换为列表
- step3. 从左向右扫描标记列表
- step4. 若标记为操作数,则将其转换为一个float,压入栈内,
- step5. 若标记为操作符,则从栈内弹出2个操作数.第一次弹出右操作数,第二次弹出左操作数.进行相应的算术运算.
- step6. 将运算结果压入栈内
- step7. 当表达式处理完毕时,栈内仅有1个元素,这个元素就是表达式的结果.

###### 问题3:解决的步骤中暴露出的特性以及根据该特性应该选取何种数据结构

在这个过程中我们发现:<font color="red">**对操作数的操作顺序和操作数的出现顺序是相反的.**</font>操作数的操作顺序是`4->5->6`,但我们的操作顺序是先计算`5 * 6`,再计算`4 + 30`.

注意,在后序表达式中,对一个操作符和<font color="red">**从该操作符的位置从右向左找,找到的距离该操作符最近的2个**</font>操作数来讲,其运算规则为:

		距操作符较远的操作数 操作符 距操作符较近的操作数
		
举例来讲,后序表达式`6 3 /`,转化为中序表达式,应该是`6 / 3`,而非`3 / 6`.

那么我们来总结这个需求的特点:

- 1. 需要暂存操作数或可计算的表达式的计算结果(实际上这个计算结果要么是最终结果,要么是另一个操作符的操作数)
- 2. 先看到的操作数后操作,因此需要反转顺序.

根据这2个特点,解决这个问题适合的数据结构为:<font color="red">**stack**</font>

那么根据这个结论,上文中的例子,应该按如下步骤解决:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.jpg)

###### 问题4:判断一个计算后的值该如何操作

到了这个步骤,要解决的只差最后一个问题了:<font color="red">**如何得知一个计算后的值该压入栈内还是该作为结果返回?**</font>

这个问题比较简单,<font color="red">**当遍历到后序表达式的最后一个字符时,计算后的值应该返回;否则应该压入栈内等待下一次运算.**</font>

##### d3. 实现

```python
from listTailToRepresentStackTop import Stack

"""
计算一个后序表达式的值
"""


def calc_postfix_expr(postfix_expr):
    postfix_expr = postfix_expr.split()

    # 保存操作数的栈
    operands = Stack()

    for i in range(0, len(postfix_expr), 1):
        token = postfix_expr[i]

        # 判断token是否为操作数
        try:
            token = float(token)
            is_operand = True
        except ValueError:
            is_operand = False

        if is_operand:
            # 操作数直接压入栈
            operands.push(token)
        else:
            # 操作符则需要从栈内弹出2个操作数
            # 先弹出的放在操作符的右边
            # 后弹出的放在操作符的左边
            operand_right, operand_left = operands.pop(), operands.pop()

            # 创建临时表达式并计算临时表达式的值
            tmp_value = eval(str(operand_left) + str(token) + str(operand_right))

            if i == len(postfix_expr) - 1:
                return tmp_value
            else:
                operands.push(tmp_value)

```

## 3.4 队列

接下来学习另一个线性数据结构:队列.

### 3.4.1 何谓队列

队列:<font color="red">**有序**</font>集合,<font color="red">**添加操作发生在"尾部",移除操作发生在"头部".**</font>新元素从尾部被添加到队列中,然后一直向前移动到头部,直到成为下一个被移出的元素.

最后添加的元素必须在队列尾部等待,在队列中时间最长的元素则排在最前面.这种排序原则被称为<font color="red">**FIFO(first-in first-out),**</font>即先进先出,也称先到先得.

在生活中队列的例子其实很常见.排队买票,排队结账,排队喝starfucks.一个维护良好的队列,只允许从队列的一端进入,从队列的另一端离开.不可能发生插队或者中途离开的情况.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

操作系统使用一些队列来控制计算机进程.调度机制基于一个队列算法,使得操作系统尽可能快地执行程序,且能够服务尽可能多的用户.在打字时,有时会看到"字符出现的速度慢于击键速度"的现象.这就是由于操作系统正在处理其他的进程.击键操作就被放入了一个类似于队列的缓冲区,以便对应的字符按正确的顺序显示.

### 3.4.2 队列抽象数据类型

#### a. 队列的特性

- 1. 有序集合
- 2. 添加操作发生在尾部,移除操作发生在头部.
- 3. 操作顺序为FIFO

#### b. 队列支持的操作

- 1. Queue():创建一个空队列,该方法不需要参数,返回值为一个空队列.
- 2. enqueue(item):将一个元素添加到队尾.该方法接收一个item作为参数,无返回值.
- 3. dequeue():将队列头部的元素移除.该方法不需要参数,返回值为位于队列头部的元素,且会对队列造成修改.
- 4. is_empty():检查队列是否为空.该方法不需要参数,返回值为一个布尔类型.True表示空队列,False表示非空队列.
- 5. size():检查一个队列中元素的数量.该方法不需要参数,且会返回一个整型.

#### c. 队列操作示例

队列操作 | 队列内容 | 返回值
:-: | :-: | :-:|
queue.is_empty() | [] | True
queue.enqueue(4) | [4] | 无
queue.enqueue('dog') | ['dog', 4] | 无
queue.enqueue(True) | [True, 'dog', 4] | 无
queue.size() | [True, 'dog', 4] | 3
queue.is_empty() | [True, 'dog', 4] | False
queue.enqueue(8.4) | [8.4, True, 'dog', 4] | 无
queue.dequeue() | [8.4, True, 'dog'] | 4
queue.dequeue() | [8.4, True] | 'dog'
queue.size() | [8.4, True] | 2

### 3.4.3 用Python实现队列

和栈相似,队列也是一个有序集合.那么Python的内置数据类型中,同样是有序集合的数据类型有:

- 列表
- 字符串
- 元组

很明显,还是列表作为队列的底层是最合适的.

下一个要考量的问题就是如何实现更高效了.这个问题的本质在于如下2个实现方案的比对:

- 方案1: 使用列表的头部作为队列的头部,使用列表的尾部作为队列的尾部
- 方案2: 使用列表的头部作为队列的尾部,使用列表的尾部作为队列的头部

想要确定这2个方案哪个更好,就要分析两者的时间复杂度.

使用列表的头部作为队列的头部,使用列表的尾部作为队列的尾部:

		则移除操作的时间复杂度是O(n),添加操作的时间复杂度是O(1)
		
使用列表的头部作为队列的尾部,使用列表的尾部作为队列的头部

		则移除操作的时间复杂度是O(1),添加操作的时间复杂度是O(n)
		

综上所述:

- <font color="red">**若添加操作较多,移除操作较少,则采用"使用列表的头部作为队列的头部,使用列表的尾部作为队列的尾部"的方案效果较好**</font>
- <font color="red">**若移除操作较多,添加操作较少,则采用"使用列表的头部作为队列的尾部,使用列表的尾部作为队列的头部"的方案效果较好**</font>
- <font color="red">**若所有被添加到队列中的元素最终都会被移除,则两个方案效果相同.**</font>

方案1的实现:

```python
"""
Queue类 使用list头部表示queue头部 使用list尾部表示queue尾部
"""


class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        return self.items.insert(0, item)

    def dequeue(self):
        return self.items.pop()

    def is_empty(self):
        return self.items == []

    def size(self):
        return len(self.items)
```

方案2的实现:

```python
"""
Queue类 使用list头部表示queue尾部 使用list尾部表示queue尾部
"""


class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        return self.items.append(item)

    def dequeue(self):
        return self.items.pop(0)

    def is_empty(self):
        return self.items == []

    def size(self):
        return len(self.items)
```

### 3.4.4 模拟:传土豆

展示队列用法的一个典型方法就是模拟一个需要以FIFO方式管理数据的真实场景.考虑这样一个游戏:传土豆.

在这个游戏中,孩子们围成一圈,并以此尽可能快的传递一个土豆.在某个时刻,大家停止传递,此时手里有土豆的孩子就得退出游戏,重复上述过程,知道只剩下1个孩子.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%BC%A0%E5%9C%9F%E8%B1%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

这个游戏其实等价于著名的约瑟夫斯问题.弗拉维奥.约瑟夫斯是公园1世纪著名的历史学家.相传,约瑟夫斯当年和39个战友在山洞中对抗罗马军队.眼看着即将失败,他们决定自杀.于是他们围成一圈,从某人开始,按顺时针方向击杀第7人.约瑟夫斯同时也是一名数学家,据传说,他立刻找到了自己应该站的位置,从而是自己活到了最后.一说这个自杀活动最后只剩下他自己,他加入了罗马军队而非自杀;另一说这个自杀活动最后剩下他和另外一人,而他说服了另外一人,投降罗马军队;也有一说是每隔2人击杀一次;也有一说最后一人可以骑马逃跑.无论如何,问题是相似的.

#### a. 需求

请设计一个函数,该函数用于模拟传土豆游戏.该函数共2个参数.一个名字列表,另一个表示每次淘汰玩家时所需的传递次数(即传递多少次之后持有土豆者被淘汰).该函数返回一个字符串,该字符串表示本场游戏的胜利者.

- a. 名字列表中的第一个名字,即为游戏开始时持有土豆的玩家名字.
- b. 土豆传递的方向为:从名字列表中的第一个人,向后传递.
- c. 土豆结束一圈传递后,由第一个人开始继续向后传递,直到到达传递次数为止,此时持有土豆者被淘汰出局,继续下一轮淘汰.直到剩下1位玩家为止,游戏结束.该玩家为胜利者.

#### b. 实现思路

实际上这个需求描述的是一个环.在这个环中,先将土豆传递出去的玩家,就会先进入等待下一圈传递的序列中.而当一圈传递结束后,等待下一圈传递的序列和开始传递的序列是相同的.如下图示.

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%BC%A0%E5%9C%9F%E8%B1%86%E6%B8%B8%E6%88%8F%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

直到传递次数到达指定次数,则此时手中有土豆的玩家被淘汰.继续开始下一轮淘汰.

若游戏序列长度不为1 且 本轮传递次数未到达指定次数 进入循环

循环中:

	每次取出(注意是取出不是获得)游戏序列中的第1个玩家 添加到等待游戏的序列中 表示该玩家从手中把土豆传递给别人了
	本轮传递次数+1
	若本轮传递次数到达指定次数 则游戏序列的第1个玩家被淘汰出局 
	本轮传递次数清0 等待序列中的玩家追加到游戏序列尾部 该游戏序列成为下一轮传递的其起始序列
	若游戏序列长度为0 则说明所有人均完成了一次传递而游戏未结束 此时等待序列成为了下一轮传递的起始序列
	
代码如下:

```python
from listHeadRepresentQueueHead import Queue


def pass_potato(players, pass_num):
    current_round_num = 0
    wait_queue = Queue()
    while True:
        while current_round_num < pass_num:
            if len(players) != 0:
                # 将送出土豆的玩家放入等待序列中
                wait_queue.enqueue(players.pop())
            else:
                # 将所有等待队列中的玩家放入游戏队列
                while not wait_queue.is_empty():
                    players.append(wait_queue.dequeue())
                # 游戏队列中的第1位玩家再次开始传递土豆
                wait_queue.enqueue(players.pop())
            current_round_num += 1

        while current_round_num == pass_num:
            # 到达传递次数 淘汰玩家
            if len(players) != 0:
                # 若此时游戏队列中还有玩家 则游戏队列中的第1位玩家被淘汰
                # 等待队列中的玩家被追加到游戏队列尾部
                eliminated = players.pop(0)
                while not wait_queue.is_empty():
                    players.append(wait_queue.dequeue())
            else:
                # 此时游戏队列中没有玩家 则等待队列中的第1位玩家被淘汰
                eliminated = wait_queue.dequeue()
                while not wait_queue.is_empty():
                    players.append(wait_queue.dequeue())

            print(eliminated)

            if len(players) == 1:
                return players
```

实际上这段代码实现的并不好.如上图所示:在未淘汰玩家时,一轮传递结束后,等待序列和游戏起始序列是完全相同的.所以上文代码的第一个缺点就出现了:

- 同样的数据,在游戏序列中则为list的一个元素,在等待序列中则为Queue的一个元素.

这是没有必要的.

这还不是致命的扣分点.真正致命的地方在于:是否有必要使用另外一个队列表示等待队列?实际上送出土豆的玩家进入等待队列,和站到游戏队列的队尾,这2个操作是<font color="red">**等效的.**</font>这个致命缺陷暴露出背后的问题在于:<font color="red">**写下这段代码时,并没有充分的理解和挖掘需求.**</font>所以才说<font color="red">**使用一个额外队列表示等待队列,是致命缺点.**</font>

<font color="red">**在编写算法方向的代码时,务必要注意的2个点在于:**</font>

- <font color="red">**将问题(需求)与算法分层**</font>
- <font color="red">**将算法与代码分层**</font>

改进后的处理流程图如下:

![Image text](http://arithmeticstudy.codingfat.com/dataStructureAndArighmetic/%E4%BC%A0%E5%9C%9F%E8%B1%86%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE--%E6%94%B9%E8%89%AF%E7%89%88.jpg)

根据这个流程,我们的处理步骤应该为:

- step1. 将表示玩家姓名的list转化为Queue
- step2. 若本轮传递次数未到达指定次数,则将Queue头部元素移除,放入尾部,表示完成了一次传递
- step3. 记录本轮传递次数的计数器+1
- step4. 重复step2和step3,直到本轮传递次数到达指定次数
- step5. 将Queue头部元素移除,表示该玩家被淘汰了
- step6. 重复step2、step3、step4、step5,直到Queue的长度为1时,返回Queue中唯一的元素,该元素即为游戏获胜者

#### c. 实现

代码如下:

```python
def pass_potato(players, pass_num):
    current_round_num = 0
    players_queue = Queue()
    while len(players) != 0:
        players_queue.enqueue(players.pop(0))

    while players_queue.size() != 1:
        players_queue.enqueue(players_queue.dequeue())
        current_round_num += 1

        if current_round_num == pass_num:
            players_queue.dequeue()
            current_round_num = 0

    return players_queue.dequeue()
```
	
<font color="red">****</font>